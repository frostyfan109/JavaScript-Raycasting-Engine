var Raycaster =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/exports.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/camera.js":
/*!***********************!*\
  !*** ./src/camera.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Camera; });\n/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color */ \"./src/color.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ \"./src/util.js\");\n\r\n\r\n/**\r\n * Ray class used for performing logic\r\n *\r\n */\r\nclass Ray extends Phaser.Line {\r\n  constructor(x, y, angle, length) {\r\n    super();\r\n    this.fromAngle(x, y, angle, length);\r\n    this.origin = new Phaser.Point(this.start.x, this.start.y);\r\n    this.collisions = [];\r\n  }\r\n}\r\n\r\n/**\r\n * Native camera object used to cast rays.\r\n *\r\n * @param {PlanarObject} object - Object that the camera is attached to. May be reassigned at any point.\r\n * @param {number} [fov=100] - Fov in degrees of the camera\r\n * @param {number} [turnSpeed=3.14159] - Turn speed of the camera in radians per seconds.\r\n *\r\n */\r\nclass Camera {\r\n  constructor(object, game, fov, turnSpeed) {\r\n    this.object = object;\r\n    this.game = game;\r\n    this.fov = typeof fov !== \"undefined\" ? fov : 100;\r\n    this.turnSpeed = typeof turnSpeed !== \"undefined\" ? turnSpeed : Math.PI;\r\n\r\n    this._rays = [];\r\n  }\r\n\r\n  calculateRayCollision() {\r\n    let obj = this.object;\r\n    this._rays.forEach((ray) => {\r\n      this.object.raycaster.objects.forEach((colObj) => {\r\n        if (colObj === obj || !colObj.visible) return;\r\n        const intersection = Object(_util__WEBPACK_IMPORTED_MODULE_1__[\"intersect\"])(ray.start.x, ray.start.y, ray.end.x, ray.end.y, colObj.start.x, colObj.start.y, colObj.end.x, colObj.end.y);\r\n        if (intersection) ray.collisions.push({ p: intersection, obj: colObj });\r\n      });\r\n    });\r\n  }\r\n\r\n  castRays() {\r\n    this._rays.length = 0; // empty the ray array\r\n\r\n    // distToProjSurface = total_rays/2 / tan(half_of_fov_in_rad)\r\n    const distToProjSurface = (this.object.raycaster.totalRays / 2) / Math.tan((this.fov / 2).toRad());\r\n    for (let x = 0; x < this.object.raycaster.totalRays; x++) {\r\n      let angle = Math.atan((x - (this.object.raycaster.totalRays / 2)) / distToProjSurface);\r\n      angle += (this.object.angle.toDeg()+90).toRad();\r\n      const ray = new Ray(this.object.midPoint().x, this.object.midPoint().y, angle, this.object.raycaster.renderDistance);\r\n      this._rays.push(ray);\r\n    }\r\n  }\r\n\r\n  render() {\r\n    this.renderGround();\r\n    this.renderSky();\r\n    this.renderView();\r\n  }\r\n\r\n  renderSky(color) {\r\n    // eslint-disable-next-line no-param-reassign\r\n    if (typeof color === 'undefined') color = new _color__WEBPACK_IMPORTED_MODULE_0__[\"default\"](99, 185, 255, 1);\r\n\r\n    const ctx = this.game.canvas.getContext('2d');\r\n    ctx.beginPath();\r\n    ctx.fillStyle = color.toCSSString();\r\n    ctx.fillRect(0, 0, this.game.world.width, this.game.world.height / 2);\r\n  }\r\n\r\n  renderGround(color) {\r\n    // eslint-disable-next-line no-param-reassign\r\n    if (typeof color === 'undefined') color = new _color__WEBPACK_IMPORTED_MODULE_0__[\"default\"](226, 226, 226, 1);\r\n\r\n    const ctx = this.game.canvas.getContext('2d');\r\n    ctx.beginPath();\r\n    ctx.fillStyle = color.toCSSString();\r\n    ctx.fillRect(0, this.game.world.height / 2, this.game.world.width, this.game.world.height / 2);\r\n  }\r\n\r\n  renderView() {\r\n    this.castRays();\r\n    this.calculateRayCollision();\r\n    const ctx = this.game.canvas.getContext('2d');\r\n    const drawTimes = [];\r\n    const drawColumn = (column, color) => {\r\n      ctx.beginPath();\r\n      ctx.fillStyle = color.toCSSString();\r\n      ctx.fillRect(column.x, column.y, column.width, column.height);\r\n    };\r\n    this._rays.forEach((ray, i) => {\r\n      // eslint-disable-next-line max-len\r\n      const collisions = ray.collisions;\r\n      collisions.forEach((collision) => {\r\n        const distance = Math.sqrt(((collision.p.x - ray.origin.x) ** 2) + ((collision.p.y - ray.origin.y) ** 2));\r\n        collision.distance = distance;\r\n      });\r\n      collisions.sort((c1, c2) => c2.distance - c1.distance);\r\n      if (!this.object.raycaster.variableHeight) {\r\n        for (let m = 0; m < collisions.length; m++) {\r\n          const col = collisions[m];\r\n          col.renderThisFrame = true;\r\n          if (m > 0) {\r\n            const prevCol = collisions[m - 1];\r\n            if (col.obj.color.a === 1) {\r\n              prevCol.renderThisFrame = false;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      for (let n = 0; n < collisions.length; n++) {\r\n        const col = collisions[n];\r\n        if (!this.object.raycaster.variableHeight && col.renderThisFrame === false) {\r\n          continue;\r\n        }\r\n        const collision = col.p;\r\n        const collisionObject = col.obj;\r\n\r\n        const texture = col.obj.texture;\r\n\r\n\r\n        const rayLen = this._rays.length;\r\n        const width = (this.game.world.width / rayLen);\r\n        // console.log(width);\r\n        const dx = collision.x - ray.origin.x;\r\n        const dy = collision.y - ray.origin.y;\r\n        // const distance = Math.sqrt((dx * dx) + (dy * dy));\r\n        const distance = col.distance;\r\n        const projHeight = distance * Math.cos((Math.atan2(dy, dx) - (this.object.angle.toDeg()-90).toRad()));\r\n        const actualHeight = this.object.raycaster.variableHeight ? collisionObject.varHeight : 1;\r\n\r\n\r\n        const color = collisionObject.color;\r\n\r\n        const x = Math.floor((i) * (this.game.world.width / rayLen));\r\n\r\n        const projectedHeight = (this.game.world.height / (projHeight / this.fov));\r\n        const height = 2 * actualHeight * (projectedHeight / 2);\r\n        // Change (this.game.world.height * 2) to (this.game.world.height * verticalAngleInDegrees/360) to look up and down. Maxes at height * 360 and height * 0;\r\n        //    NOTE: Skybox/ground won't work with this method and I don't know a fix. Probably some fairly basic math.\r\n      // Change this.object.varHeight to higher or lower to move on the z-axis.\r\n        // Once at a value > 1, variable height must be enabled for it to render properly.\r\n        const y = (this.game.world.height * (this.object.verticalAngle/(Math.PI*2))) - ((projectedHeight) * (this.object.z));\r\n        const column = new Phaser.Rectangle(\r\n          x, // x\r\n          y, // y\r\n          width, // width\r\n          height, // height\r\n        );\r\n\r\n        if (texture !== null) {\r\n          const textureData = texture;\r\n\r\n          const image = textureData.getCurrentFrame();\r\n          if (image === undefined) {\r\n            drawColumn(column, color);\r\n          } else {\r\n            const distanceFromStart = Math.sqrt(((collision.x - collisionObject.start.x) ** 2) + ((collision.y - collisionObject.start.y) ** 2));\r\n            const pixelColumn = Object(_util__WEBPACK_IMPORTED_MODULE_1__[\"scale\"])(distanceFromStart, 0, collisionObject.length, 0, image.width);\r\n            // console.log(image.width,image.height);\r\n            const imageHeight = image.height;\r\n\r\n            const t1 = Date.now();\r\n\r\n            ctx.drawImage(\r\n              image, // image\r\n              pixelColumn, // imageX\r\n              0, // imageY\r\n              1, // imageWidth\r\n              imageHeight, // imageHeight\r\n              column.x, // canvasX\r\n              column.y, // canvasY\r\n              column.width, // imageScaleWidth\r\n              column.height, // imageScaleHeight\r\n            );\r\n            drawTimes.push(Date.now() - t1);\r\n          }\r\n        } else {\r\n          drawColumn(column, color);\r\n        }\r\n      }\r\n    });\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://Raycaster/./src/camera.js?");

/***/ }),

/***/ "./src/color.js":
/*!**********************!*\
  !*** ./src/color.js ***!
  \**********************/
/*! exports provided: rgbToHex, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rgbToHex\", function() { return rgbToHex; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Color; });\n/**\r\n * Utility function used to convert an array of [r, g, b] to a CSS hex string\r\n *\r\n *\r\n */\r\nfunction rgbToHex(r, g, b) {\r\n  return (\r\n    (1 << 24) // eslint-disable-line no-bitwise\r\n    + (r << 16) // eslint-disable-line no-bitwise\r\n    + (g << 8) // eslint-disable-line no-bitwise\r\n    + b\r\n  ).toString(16).slice(1);\r\n}\r\n\r\n/**\r\n * Native color class used in engine, in the format rgba.\r\n * Note: Alpha is supported, but, when used in large quantities, may result in significant loss of performance.\r\n */\r\nclass Color {\r\n  constructor(r, g, b, a=1) {\r\n    this.r = r;\r\n    this.g = g;\r\n    this.b = b;\r\n    this.a = a;\r\n  }\r\n\r\n  toHex() {\r\n    return parseInt(rgbToHex(this.r, this.g, this.b), 16);\r\n  }\r\n\r\n  toCSSString() {\r\n    return `rgba(${this.r},${this.g},${this.b},${this.a})`;\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://Raycaster/./src/color.js?");

/***/ }),

/***/ "./src/engine.js":
/*!***********************!*\
  !*** ./src/engine.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Raycaster; });\n/* harmony import */ var _texture__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./texture */ \"./src/texture.js\");\n/* harmony import */ var _objects__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./objects */ \"./src/objects.js\");\n/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./color */ \"./src/color.js\");\n\n\n\n\nclass Raycaster {\n  /*\n  Main class used to perform update logic and handle the game state\n\n  @param {number} width - Width in pixels of game instances\n  @param {number} height - Height in pixels of game instances\n  @param {string | HTMlElement} parent - Parent element that game instances will be created within\n  @param {number} [renderDistance=100000] - Max length in pixels of rays that Entities cast out\n    Has infinitesimal effect on performance\n  @param {number} [totalRays=null] - Total amount of rays that are cast out by an Entity\n    Recommended to be left as null as it uses it will use the width of the game instances\n    Can be reduced or increased to increase or reduce fps respectively\n  @param {boolean} [debug=false] - Sets if the debugger is shown.\n  @param {Object} [options={}] - Additional optional parameters to speed up initialization of object\n  @param {number} [options.worldWidth=null] - If not null, the world will have defined width. Required along with options.worldHeight in order to use any map related utilities.\n  @param {number} [options.worldHeight=null] - If not null, the world will have defined height. Required along with options.worldWidth in order to use any map related utilities.\n  @param {Boolean} [options.variableHeight=false] - Sets if PlanarObjects not of type Entity may have variable height\n    Must be set in order for variable height to render properly or else taller objects will not be rendered when behind shorter ones\n    // NOTE: Variable height results in some loss of performance\n  @param {Phaser.State | null} [options.assetLoadState=null] - Loads all assets synchronously before proceeding to the preload state. If null, loads assets asynchronously.\n  */\n  constructor(canvasWidth, canvasHeight, parent, renderDistance = 1e7, totalRays = null, debug = false, options = {}) {\n    this.options = {\n      worldWidth: null,\n      worldHeight: null,\n      variableHeight: false,\n      assetLoadState: null,\n    };\n    Object.keys(options).forEach((key) => {\n      if (Object.prototype.hasOwnProperty.call(this.options, key)) {\n        this.options[key] = options[key];\n      }\n    });\n    Object.keys(this.options).forEach((key) => {\n      this[key] = this.options[key];\n    });\n    delete this.options;\n\n    this.renderDistance = renderDistance;\n    this.debugMode = debug;\n\n    this.totalRays = typeof totalRays === 'undefined' || totalRays === null || totalRays === undefined ? canvasWidth : totalRays;\n    if (this.totalRays > canvasWidth) throw new Error(\"Total rays must not exceed canvas width or it results in translucent walls\");\n\n\n    this.create = new Raycaster.ObjectFactory(this);\n\n    this.renderFPS = debug;\n    this.debugObjects = [];\n    this.instanceWidth = canvasWidth;\n    this.instanceHeight = canvasHeight;\n    this.instanceParent = parent;\n    this.gameInstances = [];\n    this.objects = [];\n    this.running = false;\n\n    this.prevTime = Date.now();\n\n    this._textures = [];\n  }\n\n  init() {\n    this.debugInstance = new Phaser.Game(this.instanceWidth, this.instanceHeight, this.instanceParent, Phaser.CANVAS);\n    if (!this.debugMode) {\n      this.debugInstance.canvas.style.display = 'none';\n    } else {\n      this.debugInstance.time.advancedTiming = true;\n    }\n    this.debugCamera = new Phaser.Camera(this.debugInstance,0,0,this.instanceWidth,this.instanceHeight);\n  }\n\n  loadImage(key, path) {\n    this.gameInstances.forEach((g) => {\n      g.load.image(key, path);\n    });\n    return key;\n  }\n\n  getTextureData(key) {\n    return this._textures[key];\n  }\n\n  loadTexture(key, path, options = {}, callback = null) {\n    /*\n    Loads a texture into the cache.\n\n    @param {String} key - Key stored in cache to fetch TextureData\n    @param {String} path - File path or URI that is loaded as a texture\n    @param {Object} options - Array of additional arguments\n    @param {Boolean} options.alpha - (ONLY SUPPORTS .GIFS WITH FRAMES OF DISPOSAL TYPE 1) If false, the alpha layer of the .gif will be removed\n    @param {function(TextureData)} callback - Called when the texture finishes loading\n\n    @returns {TextureData} - Cached reference to texture which can be used to instantiate a texture\n      NOTE: When instantiating a texture, it is recommended to use Raycaster::create::texture(String key) as it is more concise, although there is no practical difference.\n    */\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', path, true);\n    xhr.responseType = 'blob';\n\n    const texture = new _texture__WEBPACK_IMPORTED_MODULE_0__[\"TextureData\"](key, path);\n\n    this._textures[key] = texture;\n\n    xhr.onreadystatechange = () => {\n      if (xhr.readyState === XMLHttpRequest.DONE) {\n        texture.load(xhr.response, options).then(() => {\n          if (typeof callback === 'function') {\n            callback(texture);\n          }\n        });\n      }\n    };\n\n    xhr.send();\n\n    return texture;\n\n    // return key;\n  }\n\n  createGame(g) {\n    const { preload } = g;\n    g.preload = (...args) => {\n      // eslint-disable-next-line no-use-before-define\n      instance.time.totalFrames = 0;\n      preload(...args);\n    };\n\n\n    const loadState = this.assetLoadState;\n    if (loadState !== null) {\n      const loadStatePreload = loadState.preload;\n      loadState.preload = (...args) => {\n        preload();\n        loadStatePreload(...args);\n        const int = 10;\n        const f = () => {\n          if (Object.values(this._textures).every(t => t.loaded)) {\n            // eslint-disable-next-line no-use-before-define\n            instance.state.start('main');\n          } else {\n            setTimeout(f, int);\n          }\n        };\n        setTimeout(f, int);\n      };\n      delete g.preload;\n    }\n\n\n    const { create } = g;\n    g.create = (...args) => {\n      if (this.worldWidth !== null && this.worldHeight !== null) {\n        this.addGameObjects(\n          this.create.wallBlock(0,0,this.worldWidth,this.worldHeight, _objects__WEBPACK_IMPORTED_MODULE_1__[\"Wall\"],{color:new _color__WEBPACK_IMPORTED_MODULE_2__[\"default\"](255,255,255,1)})\n        );\n      }\n      create(...args);\n    }\n\n\n    const { render } = g;\n    g.render = (...args) => {\n      // eslint-disable-next-line no-use-before-define\n      instance.time.totalFrames++;\n      render(...args);\n      this.renderDebug();\n    };\n\n    const state = this.assetLoadState !== null ? loadState : g;\n    let instance = new Phaser.Game(this.instanceWidth, this.instanceHeight, Phaser.CANVAS, this.instanceParent, state);\n    instance.state.add('main', g);\n    this.gameInstances.push(instance);\n    return instance;\n  }\n\n  start() {\n    this.debugInstance.physics.startSystem(Phaser.Physics.ARCADE);\n\n    // this.player = new Player(this.game,50,50);\n    // this.addGameObject(this.player);\n    // this.addGameObject(new Wall(this.game,200,200,400,400));\n    this.running = true;\n  }\n\n  /**\n   * Adds a game object (inherits PlanarObject) to the raycaster instance\n   */\n  addGameObject(obj) {\n    this.objects.push(obj);\n  }\n\n  /**\n   * Recursively adds all game objects inside of `objs` to the raycaster instance\n   */\n  addGameObjects(objs) {\n    objs.forEach((obj) => {\n      if (Array.isArray(obj)) {\n        this.addGameObjects(obj);\n      } else {\n        this.addGameObject(obj);\n      }\n    });\n  }\n\n  removeGameObject(obj) {\n    this.objects = this.objects.filter(o => o !== obj);\n  }\n\n  update() {\n    const newTime = Date.now();\n    const delta = newTime - this.prevTime;\n    this.prevTime = newTime;\n\n    // Runs time logic still to prevent something like tabbing out from resulting in huge time delta when tabbing back in.\n\n    if (!this.running) return;\n\n    this.objects.forEach((obj) => {\n      obj.preUpdate();\n      obj.update(delta);\n    });\n\n  }\n\n\n\n  renderDebug() {\n    this.objects.forEach((obj) => {\n      obj.render();\n      if (obj instanceof _objects__WEBPACK_IMPORTED_MODULE_1__[\"PlanarObject\"]) {\n        if (this.debugMode) {\n          this.debugInstance.debug.geom(obj, obj.color.toCSSString());\n          if (obj.camera !== null) {\n            obj.rays.forEach((ray) => {\n              if (obj.drawFov) {\n                this.debugInstance.debug.geom(new Phaser.Line(ray.origin.x, ray.origin.y, ray.end.x, ray.end.y), '#ff0000');\n              }\n              if (obj.drawCollision) {\n                ray.collisions.forEach((collision) => {\n                  this.debugInstance.debug.geom(new Phaser.Line(ray.origin.x, ray.origin.y, collision.p.x, collision.p.y), '#00ff00');\n                });\n              }\n            });\n          }\n        }\n        if (this.renderFPS) {\n          [...this.gameInstances, this.debugInstance].forEach((instance) => {\n            if (instance.time.advancedTiming !== true) {\n              instance.time.advancedTiming = true;\n              return;\n            }\n            let ctx = instance.canvas.getContext('2d');\n            if (ctx !== null) {\n              ctx.font = \"20px Arial\";\n              ctx.fillStyle = \"#000000\";\n              ctx.fillText(\"FPS: \"+instance.time.fps, 20, 35);\n\n              ctx.font = \"14px Arial\";\n              ctx.fillStyle = \"#000000\";\n              this.debugObjects.forEach((obj, i) => {\n                const objRepr = `${obj.constructor.name}(${Math.round(obj.x)}, ${Math.round(obj.y)})`;\n                ctx.fillText(objRepr, 20, 70+(i*30));\n              });\n            }\n          });\n        }\n      }\n    });\n  }\n}\n\nRaycaster.ObjectFactory = function ObjectFactory(raycaster) {\n  return {\n    planarObject(...args) {\n      return new _objects__WEBPACK_IMPORTED_MODULE_1__[\"PlanarObject\"](raycaster, ...args);\n    },\n\n    wall(...args) {\n      return new _objects__WEBPACK_IMPORTED_MODULE_1__[\"Wall\"](raycaster, ...args);\n    },\n\n    wallBlock(...args) {\n      return Object(_objects__WEBPACK_IMPORTED_MODULE_1__[\"wallBlock\"])(raycaster, ...args);\n    },\n\n    entity(...args) {\n      return new _objects__WEBPACK_IMPORTED_MODULE_1__[\"Wall\"](raycaster, ...args);\n    },\n\n    texture(...args) {\n      return new _texture__WEBPACK_IMPORTED_MODULE_0__[\"Texture\"](...args);\n    },\n\n  };\n};\n\n// eslint-disable-next-line no-extend-native\nNumber.prototype.toRad = function toRad() {\n  return this * (Math.PI / 180);\n};\n\n// eslint-disable-next-line no-extend-native\nNumber.prototype.toDeg = function toDeg() {\n  return this * (180 / Math.PI);\n};\n\n// eslint-disable-next-line no-extend-native\nNumber.prototype.clamp = function clamp(min, max) {\n  return Math.min(Math.max(this, min), max);\n};\n\n\n//# sourceURL=webpack://Raycaster/./src/engine.js?");

/***/ }),

/***/ "./src/errors.js":
/*!***********************!*\
  !*** ./src/errors.js ***!
  \***********************/
/*! exports provided: BoundsError */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BoundsError\", function() { return BoundsError; });\nclass BoundsError extends Error {\n  constructor(...args) {\n    super(...args);\n    this.name = this.constructor.name;\n  }\n}\n\n\n//# sourceURL=webpack://Raycaster/./src/errors.js?");

/***/ }),

/***/ "./src/exports.js":
/*!************************!*\
  !*** ./src/exports.js ***!
  \************************/
/*! exports provided: Engine, Texture, MapBuilder, Minimap, Wall, Camera, constructWallBlock, PlanarObject, Entity, Color */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./engine */ \"./src/engine.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Engine\", function() { return _engine__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; });\n\n/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color */ \"./src/color.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Color\", function() { return _color__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; });\n\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ \"./src/util.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MapBuilder\", function() { return _util__WEBPACK_IMPORTED_MODULE_2__[\"MapBuilder\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Minimap\", function() { return _util__WEBPACK_IMPORTED_MODULE_2__[\"Minimap\"]; });\n\n/* harmony import */ var _texture__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./texture */ \"./src/texture.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Texture\", function() { return _texture__WEBPACK_IMPORTED_MODULE_3__[\"Texture\"]; });\n\n/* harmony import */ var _camera__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./camera */ \"./src/camera.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Camera\", function() { return _camera__WEBPACK_IMPORTED_MODULE_4__[\"Camera\"]; });\n\n/* harmony import */ var _objects__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./objects */ \"./src/objects.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Wall\", function() { return _objects__WEBPACK_IMPORTED_MODULE_5__[\"Wall\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"constructWallBlock\", function() { return _objects__WEBPACK_IMPORTED_MODULE_5__[\"wallBlock\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PlanarObject\", function() { return _objects__WEBPACK_IMPORTED_MODULE_5__[\"PlanarObject\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Entity\", function() { return _objects__WEBPACK_IMPORTED_MODULE_5__[\"Entity\"]; });\n\n\r\n\n\n\r\n\n\n\n\n\n\n//# sourceURL=webpack://Raycaster/./src/exports.js?");

/***/ }),

/***/ "./src/external/gifuct-js.min.js":
/*!***************************************!*\
  !*** ./src/external/gifuct-js.min.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var require;var require;!(function e(r, t, a) { function n(i, o) { if (!t[i]) { if (!r[i]) { const p = typeof require === 'function' && require; if (!o && p) return require(i, !0); if (s) return s(i, !0); const l = new Error(`Cannot find module '${i}'`); throw l.code = 'MODULE_NOT_FOUND', l; } const u = t[i] = { exports: {} }; r[i][0].call(u.exports, (e) => { const t = r[i][1][e]; return n(t || e); }, u, u.exports, e, r, t, a); } return t[i].exports; } for (var s = typeof require === 'function' && require, i = 0; i < a.length; i++)n(a[i]); return n; }({\n  1: [function (e, r, t) { function a(e) { this.data = e, this.pos = 0; }a.prototype.readByte = function () { return this.data[this.pos++]; }, a.prototype.peekByte = function () { return this.data[this.pos]; }, a.prototype.readBytes = function (e) { for (var r = new Array(e), t = 0; e > t; t++)r[t] = this.readByte(); return r; }, a.prototype.peekBytes = function (e) { for (var r = new Array(e), t = 0; e > t; t++)r[t] = this.data[this.pos + t]; return r; }, a.prototype.readString = function (e) { for (var r = '', t = 0; e > t; t++)r += String.fromCharCode(this.readByte()); return r; }, a.prototype.readBitArray = function () { for (var e = [], r = this.readByte(), t = 7; t >= 0; t--)e.push(!!(r & 1 << t)); return e; }, a.prototype.readUnsigned = function (e) { const r = this.readBytes(2); return e ? (r[1] << 8) + r[0] : (r[0] << 8) + r[1]; }, r.exports = a; }, {}],\n  2: [function (e, r, t) { function a(e) { this.stream = new s(e), this.output = {}; } function n(e) { return e.reduce((e, r) => 2 * e + r, 0); } var s = e('./bytestream'); a.prototype.parse = function (e) { return this.parseParts(this.output, e), this.output; }, a.prototype.parseParts = function (e, r) { for (let t = 0; t < r.length; t++) { const a = r[t]; this.parsePart(e, a); } }, a.prototype.parsePart = function (e, r) { let t; const a = r.label; if (!r.requires || r.requires(this.stream, this.output, e)) if (r.loop) { for (var n = []; r.loop(this.stream);) { const s = {}; this.parseParts(s, r.parts), n.push(s); }e[a] = n; } else r.parts ? (t = {}, this.parseParts(t, r.parts), e[a] = t) : r.parser ? (t = r.parser(this.stream, this.output, e), r.skip || (e[a] = t)) : r.bits && (e[a] = this.parseBits(r.bits)); }, a.prototype.parseBits = function (e) { const r = {}; const t = this.stream.readBitArray(); for (const a in e) { const s = e[a]; r[a] = s.length ? n(t.slice(s.index, s.index + s.length)) : t[s.index]; } return r; }, r.exports = a; }, { './bytestream': 1 }],\n  3: [function (e, r, t) {\n    const a = {\n      readByte() { return function (e) { return e.readByte(); }; }, readBytes(e) { return function (r) { return r.readBytes(e); }; }, readString(e) { return function (r) { return r.readString(e); }; }, readUnsigned(e) { return function (r) { return r.readUnsigned(e); }; }, readArray(e, r) { return function (t, a, n) { for (var s = r(t, a, n), i = new Array(s), o = 0; s > o; o++)i[o] = t.readBytes(e); return i; }; },\n    }; r.exports = a;\n  }, {}],\n  4: [function (e, r, t) { let a = window.GIF || {}; a = e('./gif'), window.GIF = a; }, { './gif': 5 }],\n  5: [function (e, r, t) {\n    function a(e) { const r = new Uint8Array(e); const t = new n(r); this.raw = t.parse(s), this.raw.hasImages = !1; for (let a = 0; a < this.raw.frames.length; a++) if (this.raw.frames[a].image) { this.raw.hasImages = !0; break; } } var n = e('../bower_components/js-binary-schema-parser/src/dataparser'); var s = e('./schema'); a.prototype.decompressFrame = function (e, r) {\n      function t(e, r, t) { let a; let n; let s; let i; let o; let p; let l; let u; let d; let c; let f; let h; let y; let g; let b; let m; const v = 4096; const x = -1; const w = t; const B = new Array(t); const k = new Array(v); const A = new Array(v); const S = new Array(v + 1); for (h = e, n = 1 << h, o = n + 1, a = n + 2, l = x, i = h + 1, s = (1 << i) - 1, d = 0; n > d; d++)k[d] = 0, A[d] = d; for (f = u = count = y = g = m = b = 0, c = 0; w > c;) { if (g === 0) { if (i > u) { f += r[b] << u, u += 8, b++; continue; } if (d = f & s, f >>= i, u -= i, d > a || d == o) break; if (d == n) { i = h + 1, s = (1 << i) - 1, a = n + 2, l = x; continue; } if (l == x) { S[g++] = A[d], l = d, y = d; continue; } for (p = d, d == a && (S[g++] = y, d = l); d > n;)S[g++] = A[d], d = k[d]; y = 255 & A[d], S[g++] = y, v > a && (k[a] = l, A[a] = y, a++, (a & s) === 0 && v > a && (i++, s += a)), l = p; }g--, B[m++] = S[g], c++; } for (c = m; w > c; c++)B[c] = 0; return B; } function a(e, r) { for (var t = new Array(e.length), a = e.length / r, n = function (a, n) { const s = e.slice(n * r, (n + 1) * r); t.splice.apply(t, [a * r, r].concat(s)); }, s = [0, 4, 2, 1], i = [8, 8, 4, 2], o = 0, p = 0; p < 4; p++) for (let l = s[p]; a > l; l += i[p])n(l, o), o++; return t; } function n(e) { for (var r = e.pixels.length, t = new Uint8ClampedArray(4 * r), a = 0; r > a; a++) { const n = 4 * a; const s = e.pixels[a]; const i = e.colorTable[s]; t[n] = i[0], t[n + 1] = i[1], t[n + 2] = i[2], t[n + 3] = s !== e.transparentIndex ? 255 : 0; } return t; } if (e >= this.raw.frames.length) return null; const s = this.raw.frames[e]; if (s.image) {\n        const i = s.image.descriptor.width * s.image.descriptor.height; let o = t(s.image.data.minCodeSize, s.image.data.blocks, i); s.image.descriptor.lct.interlaced && (o = a(o, s.image.descriptor.width)); const p = {\n          pixels: o,\n          dims: {\n            top: s.image.descriptor.top, left: s.image.descriptor.left, width: s.image.descriptor.width, height: s.image.descriptor.height,\n          },\n        }; return p.colorTable = s.image.descriptor.lct && s.image.descriptor.lct.exists ? s.image.lct : this.raw.gct, s.gce && (p.delay = 10 * (s.gce.delay || 10), p.disposalType = s.gce.extras.disposal, s.gce.extras.transparentColorGiven && (p.transparentIndex = s.gce.transparentColorIndex)), r && (p.patch = n(p)), p;\n      } return null;\n    }, a.prototype.decompressFrames = function (e) { for (var r = [], t = 0; t < this.raw.frames.length; t++) { const a = this.raw.frames[t]; a.image && r.push(this.decompressFrame(t, e)); } return r; }, r.exports = a;\n  }, { '../bower_components/js-binary-schema-parser/src/dataparser': 2, './schema': 6 }],\n  6: [function (e, r, t) {\n    const a = e('../bower_components/js-binary-schema-parser/src/parsers'); const n = { label: 'blocks', parser(e) { for (var r = [], t = 0, a = e.readByte(); a !== t; a = e.readByte())r = r.concat(e.readBytes(a)); return r; } }; const s = {\n      label: 'gce',\n      requires(e) { const r = e.peekBytes(2); return r[0] === 33 && r[1] === 249; },\n      parts: [{ label: 'codes', parser: a.readBytes(2), skip: !0 }, { label: 'byteSize', parser: a.readByte() }, {\n        label: 'extras',\n        bits: {\n          future: { index: 0, length: 3 }, disposal: { index: 3, length: 3 }, userInput: { index: 6 }, transparentColorGiven: { index: 7 },\n        },\n      }, { label: 'delay', parser: a.readUnsigned(!0) }, { label: 'transparentColorIndex', parser: a.readByte() }, { label: 'terminator', parser: a.readByte(), skip: !0 }],\n    }; const i = {\n      label: 'image',\n      requires(e) { const r = e.peekByte(); return r === 44; },\n      parts: [{ label: 'code', parser: a.readByte(), skip: !0 }, {\n        label: 'descriptor',\n        parts: [{ label: 'left', parser: a.readUnsigned(!0) }, { label: 'top', parser: a.readUnsigned(!0) }, { label: 'width', parser: a.readUnsigned(!0) }, { label: 'height', parser: a.readUnsigned(!0) }, {\n          label: 'lct',\n          bits: {\n            exists: { index: 0 }, interlaced: { index: 1 }, sort: { index: 2 }, future: { index: 3, length: 2 }, size: { index: 5, length: 3 },\n          },\n        }],\n      }, { label: 'lct', requires(e, r, t) { return t.descriptor.lct.exists; }, parser: a.readArray(3, (e, r, t) => Math.pow(2, t.descriptor.lct.size + 1)) }, { label: 'data', parts: [{ label: 'minCodeSize', parser: a.readByte() }, n] }],\n    }; const o = { label: 'text', requires(e) { const r = e.peekBytes(2); return r[0] === 33 && r[1] === 1; }, parts: [{ label: 'codes', parser: a.readBytes(2), skip: !0 }, { label: 'blockSize', parser: a.readByte() }, { label: 'preData', parser(e, r, t) { return e.readBytes(t.text.blockSize); } }, n] }; const p = { label: 'application', requires(e, r, t) { const a = e.peekBytes(2); return a[0] === 33 && a[1] === 255; }, parts: [{ label: 'codes', parser: a.readBytes(2), skip: !0 }, { label: 'blockSize', parser: a.readByte() }, { label: 'id', parser(e, r, t) { return e.readString(t.blockSize); } }, n] }; const l = { label: 'comment', requires(e, r, t) { const a = e.peekBytes(2); return a[0] === 33 && a[1] === 254; }, parts: [{ label: 'codes', parser: a.readBytes(2), skip: !0 }, n] }; const u = { label: 'frames', parts: [s, p, l, i, o], loop(e) { const r = e.peekByte(); return r === 33 || r === 44; } }; const d = [{ label: 'header', parts: [{ label: 'signature', parser: a.readString(3) }, { label: 'version', parser: a.readString(3) }] }, {\n      label: 'lsd',\n      parts: [{ label: 'width', parser: a.readUnsigned(!0) }, { label: 'height', parser: a.readUnsigned(!0) }, {\n        label: 'gct',\n        bits: {\n          exists: { index: 0 }, resolution: { index: 1, length: 3 }, sort: { index: 4 }, size: { index: 5, length: 3 },\n        },\n      }, { label: 'backgroundColorIndex', parser: a.readByte() }, { label: 'pixelAspectRatio', parser: a.readByte() }],\n    }, { label: 'gct', requires(e, r) { return r.lsd.gct.exists; }, parser: a.readArray(3, (e, r) => Math.pow(2, r.lsd.gct.size + 1)) }, u]; r.exports = d;\n  }, { '../bower_components/js-binary-schema-parser/src/parsers': 3 }],\n}, {}, [4]));\n\n\n//# sourceURL=webpack://Raycaster/./src/external/gifuct-js.min.js?");

/***/ }),

/***/ "./src/objects.js":
/*!************************!*\
  !*** ./src/objects.js ***!
  \************************/
/*! exports provided: PlanarObject, Wall, wallBlock */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PlanarObject\", function() { return PlanarObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Wall\", function() { return Wall; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"wallBlock\", function() { return wallBlock; });\n/* harmony import */ var _camera__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./camera */ \"./src/camera.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors */ \"./src/errors.js\");\n/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./color */ \"./src/color.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util */ \"./src/util.js\");\n\n\n\n\n\nclass PlanarObject extends Phaser.Line {\n  /*\n  Native renderable object (the equivalent of a line in the Euclidean plane)\n\n  @param {number} x - Initial starting x-axis coordinate\n  @param {number} y - Initial starting y-axis coordinate\n  @param {number} x2 - Initial ending x-axis coordinate\n  @param {number} y2 - Initial ending y-axis coordinate\n  @param {Object} [options={}] - Additional PlanarObject options\n  @param {Boolean} [options.collision=true] - Boolean regarding whether objects of type Entity will have movement blocked by the PlanarObject\n  @param {number} [options.height=1] - Initial height of object (relative to the projected height of the object)\n  @param {String} [options.texture=null] - Image key referencing the cached texture (must be preloaded into the cache)\n  @param {Color} [options.color=new Color(255,255,255,1)] - Color object of the object (given a texture is not present)\n    // NOTE: It is not recommended to use colors of very high intensity, such as rgb(255,255,0), nor those of very low intensity, such as rgb(5,5,0)\n    // NOTE: but rather shades such as rgb(230,230,0).\n    // NOTE: This is because with colors of very high or low intensity, opacity will often not be perceivable as it either brightens or darkens the color.\n\n  @param {Boolean} [options.render=true] - Boolean regarding whether or not the object will be rendered\n  */\n  constructor(raycaster, x, y, x2, y2, options = {}) {\n    super(x, y, x2, y2);\n    this.raycaster = raycaster;\n\n\n\n    this.camera = null;\n\n    this.options = {\n      collision: true,\n      varHeight: 1,\n      texture: null,\n      color: new _color__WEBPACK_IMPORTED_MODULE_2__[\"default\"](255, 255, 255, 1),\n      visible: true,\n    };\n\n    Object.keys(options).forEach((key) => {\n      if (Object.prototype.hasOwnProperty.call(this.options, key)) {\n        this.options[key] = options[key];\n      }\n    });\n    Object.keys(this.options).forEach((key) => {\n      this[key] = this.options[key];\n    });\n    delete this.options;\n\n    // if (typeof this.options.color === \"string\") this.options.color = new Color(this.options.color); //TODO\n    if (this.texture instanceof String || typeof this.texture === 'string') {\n      this.texture = raycaster.create.texture(raycaster.getTextureData(this.texture));\n    }\n\n    // Experimental\n    this.verticalAngle = Math.PI;\n    this.z = .5;\n\n    this.mass = 1;\n    this.velocity = {\n      x: 0,\n      y: 0\n    };\n    this.terminalVelocity = {\n      x: null,\n      y: null\n    };\n    this.friction = {\n      x: 0,\n      y: 0\n    };\n\n\n    const error = new _errors__WEBPACK_IMPORTED_MODULE_1__[\"BoundsError\"](`PlanarObject ${this.toString()} instantiated outside of world bounds`);\n    if (\n      (raycaster.worldWidth !== null && Math.min(this.start.x, this.end.x) < 0)\n      || (raycaster.worldWidth !== null && Math.max(this.start.x, this.end.x) > raycaster.worldWidth)\n      || (raycaster.worldHeight !== null && Math.min(this.start.y, this.end.y) < 0)\n      || (raycaster.worldHeight !== null && Math.max(this.start.y, this.end.y) > raycaster.worldHeight)\n    ) {\n      throw error;\n    }\n  }\n\n  /**\n   * Instantiate a camera on this object\n   *\n   */\n  addCamera(game, fov, turnSpeed) {\n    this.camera = new _camera__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this, game, fov, turnSpeed);\n  }\n\n  /**\n   * Sets up the mouse. Must be called before mouse will work.\n   */\n  setupMouse(game) {\n    game.canvas.addEventListener('mousedown', () => { Object(_util__WEBPACK_IMPORTED_MODULE_3__[\"requestPointerLock\"])(game); }, this);\n    game.input.addMoveCallback((pointer, x, y, click) => { this.mouseMove(game, pointer, x, y, click); }, this);\n  }\n\n  /**\n   * When called the mouse will begin to fire callbacks on mouse move\n   *\n   */\n  enableMouse(game) {\n    game.input.mouse.start();\n  }\n\n  /**\n   * When called the mouse will cease to fire callbacks on mouse move\n   *\n   */\n  disableMouse(game) {\n    game.input.mouse.stop();\n  }\n\n  // eslint-disable-next-line\n  mouseMove(pointer, x, y, click) {\n    // Should be overloaded to add functionality to mouse\n    // Should only be used in non split screen games\n  }\n\n  /**\n   * Turn the PlanarObject horizontally.\n   *\n   * @param {number} angle  - Sets the angle relative to the current angle in radians.\n   */\n  turnHorizontally(angle) {\n    this.rotate(angle);\n  }\n\n  /**\n   * Turn the PlanarObject vertically.\n   *\n   * @param {number} angle  - Sets the angle relative to the current angle in radians.\n   */\n  turnVertically(angle) {\n    this.verticalAngle += angle;\n  }\n\n  /**\n   * Sets the angle (absolute).\n   *\n   * @param {number} angle - The angle in radians.\n   */\n   setAngle(angle) {\n     this.rotate(angle-this.angle);\n   }\n\n  /**\n   * Method for moving the PlanarObject\n   *\n   * @param {number} force - Amount of force applied to the PlanarObject\n   * @param {number} horiz - Number of value either 1 or -1 to indicate strafing.\n   * @param {number} elapsed - Elapsed time since last frame in milliseconds\n   */\n  move(force, horiz, elapsed) {\n    let ang = this.angle;\n    ang = Math.PI*2 - ang;\n    if (horiz === 1) {\n      ang += Math.PI/2;\n    }\n    else if (horiz === -1) {\n      ang -= Math.PI * (3/2);\n    }\n\n    let acceleration = force / this.mass;\n\n    this.velocity.x += acceleration * Math.sin(ang) * (elapsed/1000);\n    this.velocity.y += acceleration * Math.cos(ang) * (elapsed/1000);\n\n    // let x = speed * (Math.sin(ang));\n    // let y = speed * (Math.cos(ang));\n    // this.setTo(this.start.x+x,this.start.y+y,this.end.x+x,this.end.y+y);\n  }\n\n  handleCollision() {\n    // ifndef\n    if (!this.prevPos) {\n      this.prevPos = {\n        x: this.midPoint().x,\n        y: this.midPoint().y\n      };\n    }\n    let mid = this.midPoint();\n    const slope = [mid.y - this.prevPos.y, mid.x - this.prevPos.x];\n    let moveAngle = Math.atan2(slope[0],slope[1]).toDeg();\n    if (moveAngle < 0) moveAngle = 360 + moveAngle;\n    // console.log(moveAngle);\n    // console.log(this.sprite.body.velocity.x);\n\n    if (slope[0] !== 0 || slope[1] !== 0) {\n      for (let i=0;i<this.raycaster.objects.length;i++) {\n        let obj = this.raycaster.objects[i];\n        if (obj === this || !obj.collision) continue;\n        let intersection = Object(_util__WEBPACK_IMPORTED_MODULE_3__[\"intersect\"])(this.prevPos.x,this.prevPos.y,this.prevPos.x,mid.y,obj.start.x,obj.start.y,obj.end.x,obj.end.y);\n        let intersected = false;\n        if (intersection) {\n          intersected = true;\n          this.setTo(this.start.x,this.start.y - (mid.y-this.prevPos.y),this.end.x,this.end.y - (mid.y-this.prevPos.y));\n          // this.sprite.y = this.prevPos.y;\n\n        }\n        intersection = Object(_util__WEBPACK_IMPORTED_MODULE_3__[\"intersect\"])(this.prevPos.x,this.prevPos.y,mid.x,this.prevPos.y,obj.start.x,obj.start.y,obj.end.x,obj.end.y);\n        if (intersection) {\n          intersected = true;\n          this.setTo(this.start.x - (mid.x-this.prevPos.x),this.start.y,this.end.x - (mid.x-this.prevPos.x),this.end.y);\n          // this.sprite.x = this.prevPos.x;\n        }\n        // if (intersected) break;\n      }\n    }\n\n    this.prevPos = {\n      x: this.midPoint().x,\n      y: this.midPoint().y\n    };\n  }\n  /*\n  handleCollision() {\n    // ifndef\n    if (!this.prevPos) {\n      this.prevPos = {\n        start:{x:this.start.x,y:this.start.y},\n        end:{x:this.end.x,y:this.end.y}\n      };\n    }\n    Object.keys(this.prevPos).forEach((type) => {\n      let prevPos = this.prevPos[type];\n      // Generally bad. But fixed so it won't have any unexpected behavior.\n      let mid = this[type];\n      const slope = [mid.y - prevPos.y, mid.x - prevPos.x];\n      let moveAngle = Math.atan2(slope[0],slope[1]).toDeg();\n      if (moveAngle < 0) moveAngle = 360 + moveAngle;\n      // console.log(moveAngle);\n      // console.log(this.sprite.body.velocity.x);\n      if (slope[0] !== 0 || slope[1] !== 0) {\n        for (let i=0;i<this.raycaster.objects.length;i++) {\n          let obj = this.raycaster.objects[i];\n          if (obj === this || !obj.options.collision) continue;\n          let intersection = intersect(prevPos.x,prevPos.y,prevPos.x,mid.y,obj.start.x,obj.start.y,obj.end.x,obj.end.y);\n          let intersected = false;\n          if (intersection) {\n            intersected = true;\n            this.setTo(this.start.x,this.start.y - (mid.y-prevPos.y),this.end.x,this.end.y - (mid.y-prevPos.y));\n            // this.sprite.y = prevPos.y;\n          }\n          intersection = intersect(prevPos.x,prevPos.y,mid.x,prevPos.y,obj.start.x,obj.start.y,obj.end.x,obj.end.y);\n          if (intersection) {\n            intersected = true;\n            this.setTo(this.start.x - (mid.x-prevPos.x),this.start.y,this.end.x - (mid.x-prevPos.x),this.end.y);\n            // this.sprite.x = prevPos.x;\n          }\n          // if (intersected) break;\n        }\n      }\n    });\n    this.prevPos = {\n      start:{x:this.start.x,y:this.start.y},\n      end:{x:this.end.x,y:this.end.y}\n    };\n  }\n  */\n\n\n  // These methods may be overloaded as long as super method is called\n\n  /**\n   * Called on PlanarObject every update loop, but before the Raycaster imposes any update logic.\n   * \n   * @param {number} elapsed - Time delta in milliseconds spanning the beginning of the last frame's update loop to the beginning of the current frame's update loop\n   */\n  preUpdate(elapsed) {\n    //Called on PlanarObject every update loop, but before the Raycaster imposes any update logic\n  }\n\n  /**\n   * Called on PlanarObject every update loop, but after the Raycaster imposes any update logic.\n   *\n   * @param {number} elapsed - Time delta in milliseconds spanning the beginning of the last frame's update loop to the beginning of the current frame's update loop\n   */\n  update(elapsed) {\n    if (this.texture !== null) this.texture.update();\n\n    /* Update position */\n\n    // Apply friction\n    let acc = {\n      x: this.friction.x / this.mass,\n      y: this.friction.y / this.mass\n    };\n    let sign = Math.sign(this.velocity.x);\n    this.velocity.x -= sign * acc.x * (elapsed/1000);\n    if (Math.sign(this.velocity.x) !== sign) {\n      // If went past 0, set to 0.\n      this.velocity.x = 0;\n    }\n    sign = Math.sign(this.velocity.y);\n    this.velocity.y -= sign * acc.y * (elapsed/1000);\n    if (Math.sign(this.velocity.y) !== sign) {\n      // If went past 0, set to 0.\n      this.velocity.y = 0;\n    }\n\n    // Clamp the velocity to ensure that it does not exceed terminal velocity\n    if (this.terminalVelocity.x !== null) {\n      this.velocity.x = this.velocity.x.clamp(-this.terminalVelocity.x, this.terminalVelocity.x);\n    }\n    if (this.terminalVelocity.y !== null) {\n      this.velocity.y = this.velocity.y.clamp(-this.terminalVelocity.y, this.terminalVelocity.y);\n    }\n\n    if (this.velocity.x !== 0 || this.velocity.y !== 0) {\n      let x = this.velocity.x * (elapsed/1000);\n      let y = this.velocity.y * (elapsed/1000);\n      this.setTo(this.start.x+x,this.start.y+y,this.end.x+x,this.end.y+y);\n\n      this.handleCollision();\n    }\n\n    // const gravitationalForce = 200;\n    // let yForce = gravitationalForce + this.yForce;\n    // if (this.yForce !== undefined) {\n    //   this.yForce *= .9;\n    //   this.z -= (yForce) * (elapsed/1000) * (elapsed/1000);\n    //   this.z = Math.max(1/2, this.z);\n    // }\n  }\n\n  /**\n   * Called on PLanarObject every every render loop, but after all update logic. Only called half as frequently as update methods.\n   *\n   * @param {number} elapsed - Time delta in milliseconds spanning the beginning of the last frame's update loop to the beginning of the current frame's update loop.\n   *    NOTE: Elapsed remains a constant throughout the frame. It will not differ between each frame-related function.\n   */\n  render(elapsed) {\n  }\n\n  toString() {\n    return `[${this.constructor.name}(${this.start.x},${this.start.y},${this.end.x},${this.end.y})]`;\n  }\n}\n\nclass Wall extends PlanarObject {\n  constructor(raycaster, x, y, x2, y2, options = {}) {\n    super(raycaster, x, y, x2, y2, options);\n  }\n}\n\n/**\n * Helper function that constructs a square of walls\n *\n * @returns Wall[] - Constructed walls in the order \"top, right, bottom, left\"\n */\nfunction wallBlock(raycaster, x, y, x2, y2, WallType, options = {}) {\n  return [\n    // eslint-disable-next-line new-cap\n    new WallType(raycaster, x, y, x2, y, options),\n    new WallType(raycaster, x, y, x, y2, options),\n    new WallType(raycaster, x, y2, x2, y2, options),\n    new WallType(raycaster, x2, y, x2, y2, options),\n  ];\n}\n\n\n//# sourceURL=webpack://Raycaster/./src/objects.js?");

/***/ }),

/***/ "./src/texture.js":
/*!************************!*\
  !*** ./src/texture.js ***!
  \************************/
/*! exports provided: TextureData, Texture */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TextureData\", function() { return TextureData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Texture\", function() { return Texture; });\n/* harmony import */ var _external_gifuct_js_min__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./external/gifuct-js.min */ \"./src/external/gifuct-js.min.js\");\n/* harmony import */ var _external_gifuct_js_min__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_external_gifuct_js_min__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction GIFFrame(frame) {\n  const c = document.createElement('canvas');\n  c.width = frame.dims.width;\n  c.height = frame.dims.height;\n  const ctx = c.getContext('2d');\n  const imageData = ctx.createImageData(c.width, c.height);\n  imageData.data.set(frame.patch);\n  ctx.putImageData(imageData, 0, 0);\n\n  const img = new Image();\n  img.src = c.toDataURL();\n  img.frameLength = frame.delay;\n  return img;\n}\n\nclass TextureData {\n  constructor(key, path) {\n    this.key = key;\n    this.path = path;\n    this.frames = [];\n    this.loaded = false;\n  }\n\n  load(data, options = {}) {\n    return new Promise((resolve, reject) => {\n      const url = URL.createObjectURL(data);\n      if (/.*\\.gif/.test(this.path)) {\n        // gif\n        const reader = new FileReader();\n        reader.onload = () => {\n          const arrayBuffer = reader.result;\n          const time = Date.now();\n          // eslint-disable-next-line\n          const gif = new GIF(arrayBuffer);\n          console.log(Date.now() - time);\n          const frames = gif.decompressFrames(true);\n          if ('alpha' in options && !options.alpha) {\n            frames.forEach((f) => {\n              if (f.disposalType === 1) {\n                for (let i = 0; i < f.patch.length; i++) {\n                  if (f.patch[i] === 0) {\n                    f.patch[i] = 0;\n                  }\n                }\n              }\n            });\n          }\n          this.frames.push(...frames.map(f => GIFFrame(f)));\n          this.loaded = true;\n          URL.revokeObjectURL(url);\n          resolve();\n        };\n        reader.readAsArrayBuffer(data);\n      } else if (/.*(\\.mp4|\\.m4a|\\.m4p|\\.m4b|\\.m4r|\\.m4v)/.test(this.path)) {\n        // mp4\n        const video = document.createElement('video');\n        video.src = url;\n        video.autoplay = true;\n        video.loop = true;\n        video.onloadedmetadata = () => {\n          this.loaded = true;\n          video.width = video.videoWidth;\n          video.height = video.videoHeight;\n          // document.body.appendChild(video);\n          URL.revokeObjectURL(url);\n          resolve();\n        };\n        this.frames.push(video);\n      } else {\n        const image = new Image();\n        image.src = url;\n        image.onload = () => {\n          this.loaded = true;\n          URL.revokeObjectURL(url);\n          resolve();\n        };\n        image.onerror = () => {\n          this.loaded = true;\n          reject(new Error(`Failed to load texture '${this.key}'`));\n          URL.revokeObjectURL(url);\n        };\n        this.frames.push(image);\n      }\n    });\n  }\n}\n\nclass Texture {\n  constructor(textureData) {\n    this.textureData = textureData;\n    this.key = textureData.key;\n    this.path = textureData.path;\n    this.frames = textureData.frames;\n    this._currentFrame = 0;\n    this.elapsed = 0;\n    this.prevTime = null;\n  }\n\n  update() {\n    const currentFrame = this.getCurrentFrame();\n    // console.log(this.frames);\n    if (this.textureData.loaded && currentFrame.frameLength !== undefined) {\n      const currentTime = Date.now();\n      if (this.prevTime === null) {\n        this.prevTime = currentTime;\n      } else {\n        const elapsed = currentTime - this.prevTime;\n        this.elapsed += elapsed;\n        if (this.elapsed >= currentFrame.frameLength) {\n          this.elapsed = 0;\n          this.playNextFrame();\n        }\n        this.prevTime = currentTime;\n      }\n    }\n  }\n\n  playNextFrame() {\n    this._currentFrame++;\n    if (this._currentFrame >= this.frames.length) {\n      this._currentFrame = 0;\n    }\n  }\n\n  getCurrentFrame() {\n    return this.frames[this._currentFrame];\n  }\n}\n\n\n//# sourceURL=webpack://Raycaster/./src/texture.js?");

/***/ }),

/***/ "./src/util.js":
/*!*********************!*\
  !*** ./src/util.js ***!
  \*********************/
/*! exports provided: requestPointerLock, scale, MapBuilder, Minimap, intersect */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"requestPointerLock\", function() { return requestPointerLock; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scale\", function() { return scale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MapBuilder\", function() { return MapBuilder; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Minimap\", function() { return Minimap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"intersect\", function() { return intersect; });\n/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color */ \"./src/color.js\");\n\n\nfunction requestPointerLock(game) {\n  game.input.mouse.requestPointerLock();\n}\n\nfunction scale(num, inMin, inMax, outMin, outMax) {\n  return (num - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;\n}\n\n/*\n  Data map is in the format:\n[\n  [\n    [2, 1, 0],\n    [1, 1, 0],\n    [1, 0, 2]\n  ],\n  {\n    0: {\n      object: Wall,\n      arguments: [{height:2}]\n    },\n    1: {\n      object: Wall,\n      arguments: [{texture:'foo'}]\n    },\n    2: {\n      object: CustomWall,\n      arguments: []\n    },\n  }\n]\nNOTE: Values in first array may also be arrays in the format of [value, arguments] to override the predefined arguments for said value.\nNOTE: This format also inherently supports other data types such as strings instead of numbers to serve as instances. This may be more clear if desired.\nNOTE: Arguments passed to each class reference will go:\n  \"(raycaster instance, x1, y1, x2, y2, ...args)\"\n  If the class instance's constructor doesn't comply with this format, you may instead pass in a helper function to construct the instance:\n  // NOTE: This format also be helpful in the instantiation of new arguments every time (instead of reusing the same preinstantiated object)\n    [\n      0: {\n        helper: function(raycaster, x1, y1, x2, y2) {\n          return new CustomWall(raycaster, x1, y1, x2, y2, {texture:'bar'})\n        }\n      }\n    ]\n*/\nconst MapBuilder = {\n  build(raycaster, dataMap, xDimensions, yDimensions) {\n    const map = [];\n    const height = raycaster.worldHeight / Math.max(yDimensions, dataMap[0].length);\n    for (let yInd = 0; yInd < dataMap[0].length; yInd++) {\n      const width = raycaster.worldWidth / Math.max(xDimensions, dataMap[0][yInd].length);\n      for (let xInd = 0; xInd < dataMap[0][yInd].length; xInd++) {\n        let type = dataMap[0][yInd][xInd];\n        let object;\n        const x1 = width * xInd;\n        const x2 = x1 + width;\n        const y1 = height * yInd;\n        const y2 = y1 + height;\n\n\n        let args;\n\n        if (typeof type === \"undefined\" || type === null || type === undefined) {\n          continue;\n        }\n\n        if (Array.isArray(type)) {\n          [type, ...args] = type;\n        }\n\n        const data = dataMap[1][type];\n\n        if (typeof data === \"undefined\" || data === null || data === undefined) {\n          continue;\n        }\n\n        if (typeof args === 'undefined') args = Object.prototype.hasOwnProperty.call(data, 'arguments') ? data.arguments : [];\n\n        if (Object.prototype.hasOwnProperty.call(data, 'helper')) {\n          object = data.helper(raycaster, x1, y1, x2, y2);\n        } else {\n          // eslint-disable-next-line new-cap\n          object = new data.object(raycaster, x1, y1, x2, y2, ...args);\n        }\n        map.push(object);\n        // super(raycaster,x,y,x2,y2,height,options);\n      }\n    }\n    return map;\n  },\n  loadFromFile(file) {\n    // TODO\n\n  },\n};\n\n/**\n * Minimap utility class\n *\n * @param {PlanarObject} object - The object that the minimap is rendered relative to. May be reassigned at any point.\n * @param {number} x - X-axis coordinate in which the minimap will be rendered onto the screen;\n * @param {number} y - Y-axis coordinate in which the minimap will be rendered onto the screen;\n * @param {number} width - The width of the minimap in pixels.\n * @param {number} height - The height of the minimap in pixels.\n * @param {number|null} [viewWidth=null] - The amount of in-game width rendered on the minimap. Default shows the entire map.\n * @param {number|null} [viewHeight=null] - The amount of in-game height rendered on the minimap. Default shows the entire map.\n * @param {object} [options={}] - Additional options.\n * @param {Color} [options.backgroundColor=new Color(80,80,80,1)] - Background color of the Minimap.\n * @param {Color} [options.borderColor=new Color(50,50,50,1)] - Border color of the Minimap.\n * @param {number} [options.borderWidth=0] - Width of the Minimap's border.\n *\n */\nclass Minimap {\n  constructor(object, x, y, width, height, viewWidth=null, viewHeight=null, options={}) {\n    this.object = object;\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.viewWidth = viewWidth;\n    this.viewHeight = viewHeight;\n\n    this.options = {\n      backgroundColor:new _color__WEBPACK_IMPORTED_MODULE_0__[\"default\"](80,80,80,1),\n      borderColor:new _color__WEBPACK_IMPORTED_MODULE_0__[\"default\"](50,50,50,1),\n      borderWidth:0\n    };\n    Object.keys(options).forEach((key) => {\n      if (Object.prototype.hasOwnProperty.call(this.options, key)) {\n        this.options[key] = options[key];\n      }\n    });\n    Object.keys(this.options).forEach((key) => {\n      this[key] = this.options[key];\n    });\n    delete this.options;\n  }\n  /**\n   * Method for rendering the minimap onto the screen\n   */\n  render() {\n    let ctx = this.object.game.canvas.getContext('2d');\n    let gameWidth = this.object.raycaster.worldWidth;\n    let gameHeight = this.object.raycaster.worldHeight;\n    if (this.borderWidth !== 0) {\n      ctx.fillStyle = this.borderColor.toCSSString();\n      ctx.fillRect(this.x-this.borderWidth,this.y-this.borderWidth,this.width+(this.borderWidth*2),this.height+(this.borderWidth*2));\n    }\n    ctx.fillStyle = this.backgroundColor.toCSSString();\n    ctx.fillRect(this.x, this.y, this.width, this.height);\n    this.object.raycaster.objects.forEach((obj,i) => {\n      let color = obj.color.toCSSString();\n      let startX = this.x + this.width * (obj.start.x / gameWidth);\n      let startY = this.y + this.height * (obj.start.y / gameHeight);\n      let endX = this.x + this.width * (obj.end.x / gameWidth);\n      let endY = this.y + this.height * (obj.end.y / gameHeight);\n      ctx.strokeStyle = color;\n      ctx.moveTo(startX,startY);\n      ctx.lineTo(endX,endY);\n    });\n    ctx.stroke();\n  }\n}\n\nfunction intersect(x1, y1, x2, y2, x3, y3, x4, y4) {\n  // Check if none of the lines are of length 0\n  if ((x1 === x2 && y1 === y2) || (x3 === x4 && y3 === y4)) {\n    return false;\n  }\n\n  const denominator = ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));\n\n  // Lines are parallel\n  if (denominator === 0) {\n    return false;\n  }\n\n  const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator;\n  const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator;\n\n  // is the intersection along the segments\n  if (ua < 0 || ua > 1 || ub < 0 || ub > 1) {\n    return false;\n  }\n\n  // Return a object with the x and y coordinates of the intersection\n  const x = x1 + ua * (x2 - x1);\n  const y = y1 + ua * (y2 - y1);\n\n  return { x, y };\n}\n\n\n//# sourceURL=webpack://Raycaster/./src/util.js?");

/***/ })

/******/ });