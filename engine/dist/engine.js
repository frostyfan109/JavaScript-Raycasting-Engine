var Raycaster =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/exports.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/engine.js":
/*!***********************!*\
  !*** ./src/engine.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Raycaster; });\n/* harmony import */ var _texture__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./texture */ \"./src/texture.js\");\n/* harmony import */ var _objects__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./objects */ \"./src/objects.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ \"./src/util.js\");\n\n\n\n\nclass Raycaster {\n  /*\n  Main class used to perform update logic and handle the game state\n\n  @param {number} width - Width in pixels of game instances\n  @param {number} height - Height in pixels of game instances\n  @param {string | HTMlElement} parent - Parent element that game instances will be created within\n  @param {number} [renderDistance=100000] - Max length in pixels of rays that Entities cast out\n    Has infinitesimal effect on performance\n  @param {number} [totalRays=null] - Total amount of rays that are cast out by an Entity\n    Recommended to be left as null as it uses it will use the width of the game instances\n    Can be reduced or increased to increase or reduce fps respectively\n  @param {Object} [options={}] - Additional optional parameters to speed up initialization of object\n  @param {Object} [options.worldBounds=null] - If not null, the world will have defined boundaries. Required in order to use the map creator.\n  @param {number} [options.worldBounds.width] - Width of world\n  @param {number} [options.worldBounds.height] - Height of world\n  @param {Boolean} [options.variableHeight=false] - Sets if PlanarObjects not of type Entity may have variable height\n    Must be set in order for variable height to render properly or else taller objects will not be rendered when behind shorter ones\n    // NOTE: Variable height results in some loss of performance\n  @param {Phaser.State | null} [options.assetLoadState=null] - Loads all assets synchronously before proceeding to the preload state. If null, loads assets asynchronously.\n  */\n  constructor(canvasWidth, canvasHeight, parent, renderDistance = 1e7, totalRays = null, debug = false, options = {}) {\n    this.options = {\n      worldBounds: null,\n      variableHeight: false,\n      assetLoadState: null,\n    };\n\n    Object.keys(options).forEach((i) => {\n      this.options[i] = options[i];\n    });\n\n    this.renderDistance = renderDistance;\n    this.variableHeight = this.options.variableHeight;\n    this.debugMode = debug;\n    this.totalRays = typeof totalRays === 'undefined' || totalRays === null || totalRays === undefined ? canvasWidth : totalRays;\n\n\n    this.create = new Raycaster.ObjectFactory(this);\n\n    this.assetLoadState = this.options.assetLoadState;\n\n    this.renderFPS = !!debug;\n    this.worldWidth = options.worldBounds === null ? null : options.worldBounds.width;\n    this.worldHeight = options.worldBounds === null ? null : options.worldBounds.height;\n    this.instanceWidth = canvasWidth;\n    this.instanceHeight = canvasHeight;\n    this.instanceParent = parent;\n    this.gameInstances = [];\n    this.objects = [];\n    this.running = false;\n\n    this._textures = [];\n  }\n\n  init() {\n    this.debugInstance = new Phaser.Game(this.instanceWidth, this.instanceHeight, this.instanceParent, Phaser.CANVAS);\n    if (!this.debugMode) {\n      this.debugInstance.canvas.style.display = 'none';\n    } else {\n      this.debugInstance.time.advancedTiming = true;\n    }\n  }\n\n  loadImage(key, path) {\n    this.gameInstances.forEach((g) => {\n      g.load.image(key, path);\n    });\n    return key;\n  }\n\n  getTextureData(key) {\n    return this._textures[key];\n  }\n\n  loadTexture(key, path, options = {}, callback = null) {\n    /*\n    Loads a texture into the cache.\n\n    @param {String} key - Key stored in cache to fetch TextureData\n    @param {String} path - File path or URI that is loaded as a texture\n    @param {Object} options - Array of additional arguments\n    @param {Boolean} options.alpha - (ONLY SUPPORTS .GIFS WITH FRAMES OF DISPOSAL TYPE 1) If false, the alpha layer of the .gif will be removed\n    @param {function(TextureData)} callback - Called when the texture finishes loading\n\n    @returns {TextureData} - Cached reference to texture which can be used to instantiate a texture\n      NOTE: When instantiating a texture, it is recommended to use Raycaster::create::texture(String key) as it is more concise, although there is no practical difference.\n    */\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', path, true);\n    xhr.responseType = 'blob';\n\n    const texture = new _texture__WEBPACK_IMPORTED_MODULE_0__[\"TextureData\"](key, path);\n\n    this._textures[key] = texture;\n\n    xhr.onreadystatechange = () => {\n      if (xhr.readyState === XMLHttpRequest.DONE) {\n        texture.load(xhr.response, options).then(() => {\n          if (typeof callback === 'function') {\n            callback(texture);\n          }\n        });\n      }\n    };\n\n    xhr.send();\n\n    return texture;\n\n    // return key;\n  }\n\n  createGame(g) {\n    const { preload } = g;\n    g.preload = (...args) => {\n      // eslint-disable-next-line no-use-before-define\n      instance.time.totalFrames = 0;\n      preload(...args);\n    };\n\n\n    const loadState = this.assetLoadState;\n    if (loadState !== null) {\n      const loadStatePreload = loadState.preload;\n      loadState.preload = (...args) => {\n        preload();\n        loadStatePreload(...args);\n        const int = 10;\n        const f = () => {\n          if (Object.values(this._textures).every(t => t.loaded)) {\n            // eslint-disable-next-line no-use-before-define\n            instance.state.start('main');\n          } else {\n            setTimeout(f, int);\n          }\n        };\n        setTimeout(f, int);\n      };\n      delete g.preload;\n    }\n\n\n    const { render } = g;\n    g.render = (...args) => {\n      // eslint-disable-next-line no-use-before-define\n      instance.time.totalFrames++;\n      render(...args);\n      this.renderDebug();\n    };\n\n    const state = this.assetLoadState !== null ? loadState : g;\n    let instance = new Phaser.Game(this.instanceWidth, this.instanceHeight, Phaser.CANVAS, this.instanceParent, state);\n    instance.state.add('main', g);\n    this.gameInstances.push(instance);\n    return instance;\n  }\n\n  start() {\n    this.debugInstance.physics.startSystem(Phaser.Physics.ARCADE);\n\n    // this.player = new Player(this.game,50,50);\n    // this.addGameObject(this.player);\n    // this.addGameObject(new Wall(this.game,200,200,400,400));\n    this.running = true;\n  }\n\n  /**\n   * Adds a game object (inherits PlanarObject) to the raycaster instance\n   */\n  addGameObject(obj) {\n    this.objects.push(obj);\n  }\n\n  /**\n   * Recursively adds all game objects inside of `objs` to the raycaster instance\n   */\n  addGameObjects(objs) {\n    objs.forEach((obj) => {\n      if (Array.isArray(obj)) {\n        this.addGameObjects(obj);\n      } else {\n        this.addGameObject(obj);\n      }\n    });\n  }\n\n  removeGameObject(obj) {\n    this.objects = this.objects.filter(o => o !== obj);\n  }\n\n  update() {\n    if (!this.running) return;\n\n    this.objects.forEach((obj) => {\n      if (obj instanceof _objects__WEBPACK_IMPORTED_MODULE_1__[\"Entity\"]) {\n        obj.sprite.body.velocity.x = 0;\n        obj.sprite.body.velocity.y = 0;\n        obj.sprite.body.angularVelocity = 0;\n        obj.rotate(((90).toRad() + obj.sprite.angle.toRad()) - obj.angle);\n        obj.center();\n        obj.castRays();\n      }\n    });\n\n    this.handleRays();\n\n    this.objects.forEach((obj) => {\n      obj.update();\n    });\n  }\n\n  handleRays() {\n    this.objects.forEach((obj) => {\n      if (obj instanceof _objects__WEBPACK_IMPORTED_MODULE_1__[\"Entity\"]) {\n        obj.rays.forEach((ray) => {\n          this.objects.forEach((colObj) => {\n            if (colObj === obj || !colObj.options.render) return;\n            const intersection = Object(_util__WEBPACK_IMPORTED_MODULE_2__[\"intersect\"])(ray.start.x, ray.start.y, ray.end.x, ray.end.y, colObj.start.x, colObj.start.y, colObj.end.x, colObj.end.y);\n            if (intersection) ray.collisions.push({ p: intersection, obj: colObj });\n          });\n        });\n      }\n    });\n  }\n\n  renderDebug() {\n    this.objects.forEach((obj) => {\n      obj.render();\n      if (obj instanceof _objects__WEBPACK_IMPORTED_MODULE_1__[\"PlanarObject\"]) {\n        if (this.debugMode) {\n          this.debugInstance.debug.geom(obj, obj.options.color.toCSSString());\n          if (obj instanceof _objects__WEBPACK_IMPORTED_MODULE_1__[\"Entity\"]) {\n            obj.rays.forEach((ray) => {\n              if (obj.drawFov) {\n                this.debugInstance.debug.geom(new Phaser.Line(ray.origin.x, ray.origin.y, ray.end.x, ray.end.y), '#ff0000');\n              }\n              if (obj.drawCollision) {\n                ray.collisions.forEach((collision) => {\n                  this.debugInstance.debug.geom(new Phaser.Line(ray.origin.x, ray.origin.y, collision.p.x, collision.p.y), '#00ff00');\n                });\n              }\n            });\n          }\n        }\n        if (this.renderFPS) {\n          [...this.gameInstances, this.debugInstance].forEach((instance) => {\n            if (instance.time.advancedTiming !== true) {\n              instance.time.advancedTiming = true;\n              return;\n            }\n            instance.debug.text(instance.time.fps, 25, 25, '#00ff00');\n          });\n        }\n      }\n    });\n  }\n}\n\nRaycaster.ObjectFactory = function ObjectFactory(raycaster) {\n  return {\n    planarObject(...args) {\n      return new _objects__WEBPACK_IMPORTED_MODULE_1__[\"PlanarObject\"](raycaster, ...args);\n    },\n\n    wall(...args) {\n      return new _objects__WEBPACK_IMPORTED_MODULE_1__[\"Wall\"](raycaster, ...args);\n    },\n\n    entity(...args) {\n      return new _objects__WEBPACK_IMPORTED_MODULE_1__[\"Wall\"](raycaster, ...args);\n    },\n\n    texture(...args) {\n      return new _texture__WEBPACK_IMPORTED_MODULE_0__[\"Texture\"](...args);\n    },\n  };\n};\n\n// eslint-disable-next-line no-extend-native\nNumber.prototype.toRad = function toRad() {\n  return this * (Math.PI / 180);\n};\n\n// eslint-disable-next-line no-extend-native\nNumber.prototype.toDeg = function toDeg() {\n  return this * (180 / Math.PI);\n};\n\n// eslint-disable-next-line no-extend-native\nNumber.prototype.clamp = function clamp(min, max) {\n  return Math.min(Math.max(this, min), max);\n};\n\n\n//# sourceURL=webpack://Raycaster/./src/engine.js?");

/***/ }),

/***/ "./src/errors.js":
/*!***********************!*\
  !*** ./src/errors.js ***!
  \***********************/
/*! exports provided: BoundsError */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BoundsError\", function() { return BoundsError; });\nclass BoundsError extends Error {\n  constructor(...args) {\n    super(...args);\n    this.name = this.constructor.name;\n  }\n}\n\n\n//# sourceURL=webpack://Raycaster/./src/errors.js?");

/***/ }),

/***/ "./src/exports.js":
/*!************************!*\
  !*** ./src/exports.js ***!
  \************************/
/*! exports provided: Engine, Texture, MapBuilder, Wall, WallBlock, PlanarObject, Entity, Color */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./engine */ \"./src/engine.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Engine\", function() { return _engine__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; });\n\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ \"./src/util.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MapBuilder\", function() { return _util__WEBPACK_IMPORTED_MODULE_1__[\"MapBuilder\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Color\", function() { return _util__WEBPACK_IMPORTED_MODULE_1__[\"Color\"]; });\n\n/* harmony import */ var _texture__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./texture */ \"./src/texture.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Texture\", function() { return _texture__WEBPACK_IMPORTED_MODULE_2__[\"Texture\"]; });\n\n/* harmony import */ var _objects__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./objects */ \"./src/objects.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Wall\", function() { return _objects__WEBPACK_IMPORTED_MODULE_3__[\"Wall\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"WallBlock\", function() { return _objects__WEBPACK_IMPORTED_MODULE_3__[\"WallBlock\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PlanarObject\", function() { return _objects__WEBPACK_IMPORTED_MODULE_3__[\"PlanarObject\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Entity\", function() { return _objects__WEBPACK_IMPORTED_MODULE_3__[\"Entity\"]; });\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://Raycaster/./src/exports.js?");

/***/ }),

/***/ "./src/external/gifuct-js.min.js":
/*!***************************************!*\
  !*** ./src/external/gifuct-js.min.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var require;var require;!(function e(r, t, a) { function n(i, o) { if (!t[i]) { if (!r[i]) { const p = typeof require === 'function' && require; if (!o && p) return require(i, !0); if (s) return s(i, !0); const l = new Error(`Cannot find module '${i}'`); throw l.code = 'MODULE_NOT_FOUND', l; } const u = t[i] = { exports: {} }; r[i][0].call(u.exports, (e) => { const t = r[i][1][e]; return n(t || e); }, u, u.exports, e, r, t, a); } return t[i].exports; } for (var s = typeof require === 'function' && require, i = 0; i < a.length; i++)n(a[i]); return n; }({\n  1: [function (e, r, t) { function a(e) { this.data = e, this.pos = 0; }a.prototype.readByte = function () { return this.data[this.pos++]; }, a.prototype.peekByte = function () { return this.data[this.pos]; }, a.prototype.readBytes = function (e) { for (var r = new Array(e), t = 0; e > t; t++)r[t] = this.readByte(); return r; }, a.prototype.peekBytes = function (e) { for (var r = new Array(e), t = 0; e > t; t++)r[t] = this.data[this.pos + t]; return r; }, a.prototype.readString = function (e) { for (var r = '', t = 0; e > t; t++)r += String.fromCharCode(this.readByte()); return r; }, a.prototype.readBitArray = function () { for (var e = [], r = this.readByte(), t = 7; t >= 0; t--)e.push(!!(r & 1 << t)); return e; }, a.prototype.readUnsigned = function (e) { const r = this.readBytes(2); return e ? (r[1] << 8) + r[0] : (r[0] << 8) + r[1]; }, r.exports = a; }, {}],\n  2: [function (e, r, t) { function a(e) { this.stream = new s(e), this.output = {}; } function n(e) { return e.reduce((e, r) => 2 * e + r, 0); } var s = e('./bytestream'); a.prototype.parse = function (e) { return this.parseParts(this.output, e), this.output; }, a.prototype.parseParts = function (e, r) { for (let t = 0; t < r.length; t++) { const a = r[t]; this.parsePart(e, a); } }, a.prototype.parsePart = function (e, r) { let t; const a = r.label; if (!r.requires || r.requires(this.stream, this.output, e)) if (r.loop) { for (var n = []; r.loop(this.stream);) { const s = {}; this.parseParts(s, r.parts), n.push(s); }e[a] = n; } else r.parts ? (t = {}, this.parseParts(t, r.parts), e[a] = t) : r.parser ? (t = r.parser(this.stream, this.output, e), r.skip || (e[a] = t)) : r.bits && (e[a] = this.parseBits(r.bits)); }, a.prototype.parseBits = function (e) { const r = {}; const t = this.stream.readBitArray(); for (const a in e) { const s = e[a]; r[a] = s.length ? n(t.slice(s.index, s.index + s.length)) : t[s.index]; } return r; }, r.exports = a; }, { './bytestream': 1 }],\n  3: [function (e, r, t) {\n    const a = {\n      readByte() { return function (e) { return e.readByte(); }; }, readBytes(e) { return function (r) { return r.readBytes(e); }; }, readString(e) { return function (r) { return r.readString(e); }; }, readUnsigned(e) { return function (r) { return r.readUnsigned(e); }; }, readArray(e, r) { return function (t, a, n) { for (var s = r(t, a, n), i = new Array(s), o = 0; s > o; o++)i[o] = t.readBytes(e); return i; }; },\n    }; r.exports = a;\n  }, {}],\n  4: [function (e, r, t) { let a = window.GIF || {}; a = e('./gif'), window.GIF = a; }, { './gif': 5 }],\n  5: [function (e, r, t) {\n    function a(e) { const r = new Uint8Array(e); const t = new n(r); this.raw = t.parse(s), this.raw.hasImages = !1; for (let a = 0; a < this.raw.frames.length; a++) if (this.raw.frames[a].image) { this.raw.hasImages = !0; break; } } var n = e('../bower_components/js-binary-schema-parser/src/dataparser'); var s = e('./schema'); a.prototype.decompressFrame = function (e, r) {\n      function t(e, r, t) { let a; let n; let s; let i; let o; let p; let l; let u; let d; let c; let f; let h; let y; let g; let b; let m; const v = 4096; const x = -1; const w = t; const B = new Array(t); const k = new Array(v); const A = new Array(v); const S = new Array(v + 1); for (h = e, n = 1 << h, o = n + 1, a = n + 2, l = x, i = h + 1, s = (1 << i) - 1, d = 0; n > d; d++)k[d] = 0, A[d] = d; for (f = u = count = y = g = m = b = 0, c = 0; w > c;) { if (g === 0) { if (i > u) { f += r[b] << u, u += 8, b++; continue; } if (d = f & s, f >>= i, u -= i, d > a || d == o) break; if (d == n) { i = h + 1, s = (1 << i) - 1, a = n + 2, l = x; continue; } if (l == x) { S[g++] = A[d], l = d, y = d; continue; } for (p = d, d == a && (S[g++] = y, d = l); d > n;)S[g++] = A[d], d = k[d]; y = 255 & A[d], S[g++] = y, v > a && (k[a] = l, A[a] = y, a++, (a & s) === 0 && v > a && (i++, s += a)), l = p; }g--, B[m++] = S[g], c++; } for (c = m; w > c; c++)B[c] = 0; return B; } function a(e, r) { for (var t = new Array(e.length), a = e.length / r, n = function (a, n) { const s = e.slice(n * r, (n + 1) * r); t.splice.apply(t, [a * r, r].concat(s)); }, s = [0, 4, 2, 1], i = [8, 8, 4, 2], o = 0, p = 0; p < 4; p++) for (let l = s[p]; a > l; l += i[p])n(l, o), o++; return t; } function n(e) { for (var r = e.pixels.length, t = new Uint8ClampedArray(4 * r), a = 0; r > a; a++) { const n = 4 * a; const s = e.pixels[a]; const i = e.colorTable[s]; t[n] = i[0], t[n + 1] = i[1], t[n + 2] = i[2], t[n + 3] = s !== e.transparentIndex ? 255 : 0; } return t; } if (e >= this.raw.frames.length) return null; const s = this.raw.frames[e]; if (s.image) {\n        const i = s.image.descriptor.width * s.image.descriptor.height; let o = t(s.image.data.minCodeSize, s.image.data.blocks, i); s.image.descriptor.lct.interlaced && (o = a(o, s.image.descriptor.width)); const p = {\n          pixels: o,\n          dims: {\n            top: s.image.descriptor.top, left: s.image.descriptor.left, width: s.image.descriptor.width, height: s.image.descriptor.height,\n          },\n        }; return p.colorTable = s.image.descriptor.lct && s.image.descriptor.lct.exists ? s.image.lct : this.raw.gct, s.gce && (p.delay = 10 * (s.gce.delay || 10), p.disposalType = s.gce.extras.disposal, s.gce.extras.transparentColorGiven && (p.transparentIndex = s.gce.transparentColorIndex)), r && (p.patch = n(p)), p;\n      } return null;\n    }, a.prototype.decompressFrames = function (e) { for (var r = [], t = 0; t < this.raw.frames.length; t++) { const a = this.raw.frames[t]; a.image && r.push(this.decompressFrame(t, e)); } return r; }, r.exports = a;\n  }, { '../bower_components/js-binary-schema-parser/src/dataparser': 2, './schema': 6 }],\n  6: [function (e, r, t) {\n    const a = e('../bower_components/js-binary-schema-parser/src/parsers'); const n = { label: 'blocks', parser(e) { for (var r = [], t = 0, a = e.readByte(); a !== t; a = e.readByte())r = r.concat(e.readBytes(a)); return r; } }; const s = {\n      label: 'gce',\n      requires(e) { const r = e.peekBytes(2); return r[0] === 33 && r[1] === 249; },\n      parts: [{ label: 'codes', parser: a.readBytes(2), skip: !0 }, { label: 'byteSize', parser: a.readByte() }, {\n        label: 'extras',\n        bits: {\n          future: { index: 0, length: 3 }, disposal: { index: 3, length: 3 }, userInput: { index: 6 }, transparentColorGiven: { index: 7 },\n        },\n      }, { label: 'delay', parser: a.readUnsigned(!0) }, { label: 'transparentColorIndex', parser: a.readByte() }, { label: 'terminator', parser: a.readByte(), skip: !0 }],\n    }; const i = {\n      label: 'image',\n      requires(e) { const r = e.peekByte(); return r === 44; },\n      parts: [{ label: 'code', parser: a.readByte(), skip: !0 }, {\n        label: 'descriptor',\n        parts: [{ label: 'left', parser: a.readUnsigned(!0) }, { label: 'top', parser: a.readUnsigned(!0) }, { label: 'width', parser: a.readUnsigned(!0) }, { label: 'height', parser: a.readUnsigned(!0) }, {\n          label: 'lct',\n          bits: {\n            exists: { index: 0 }, interlaced: { index: 1 }, sort: { index: 2 }, future: { index: 3, length: 2 }, size: { index: 5, length: 3 },\n          },\n        }],\n      }, { label: 'lct', requires(e, r, t) { return t.descriptor.lct.exists; }, parser: a.readArray(3, (e, r, t) => Math.pow(2, t.descriptor.lct.size + 1)) }, { label: 'data', parts: [{ label: 'minCodeSize', parser: a.readByte() }, n] }],\n    }; const o = { label: 'text', requires(e) { const r = e.peekBytes(2); return r[0] === 33 && r[1] === 1; }, parts: [{ label: 'codes', parser: a.readBytes(2), skip: !0 }, { label: 'blockSize', parser: a.readByte() }, { label: 'preData', parser(e, r, t) { return e.readBytes(t.text.blockSize); } }, n] }; const p = { label: 'application', requires(e, r, t) { const a = e.peekBytes(2); return a[0] === 33 && a[1] === 255; }, parts: [{ label: 'codes', parser: a.readBytes(2), skip: !0 }, { label: 'blockSize', parser: a.readByte() }, { label: 'id', parser(e, r, t) { return e.readString(t.blockSize); } }, n] }; const l = { label: 'comment', requires(e, r, t) { const a = e.peekBytes(2); return a[0] === 33 && a[1] === 254; }, parts: [{ label: 'codes', parser: a.readBytes(2), skip: !0 }, n] }; const u = { label: 'frames', parts: [s, p, l, i, o], loop(e) { const r = e.peekByte(); return r === 33 || r === 44; } }; const d = [{ label: 'header', parts: [{ label: 'signature', parser: a.readString(3) }, { label: 'version', parser: a.readString(3) }] }, {\n      label: 'lsd',\n      parts: [{ label: 'width', parser: a.readUnsigned(!0) }, { label: 'height', parser: a.readUnsigned(!0) }, {\n        label: 'gct',\n        bits: {\n          exists: { index: 0 }, resolution: { index: 1, length: 3 }, sort: { index: 4 }, size: { index: 5, length: 3 },\n        },\n      }, { label: 'backgroundColorIndex', parser: a.readByte() }, { label: 'pixelAspectRatio', parser: a.readByte() }],\n    }, { label: 'gct', requires(e, r) { return r.lsd.gct.exists; }, parser: a.readArray(3, (e, r) => Math.pow(2, r.lsd.gct.size + 1)) }, u]; r.exports = d;\n  }, { '../bower_components/js-binary-schema-parser/src/parsers': 3 }],\n}, {}, [4]));\n\n\n//# sourceURL=webpack://Raycaster/./src/external/gifuct-js.min.js?");

/***/ }),

/***/ "./src/objects.js":
/*!************************!*\
  !*** ./src/objects.js ***!
  \************************/
/*! exports provided: PlanarObject, Wall, WallBlock, Entity */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PlanarObject\", function() { return PlanarObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Wall\", function() { return Wall; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WallBlock\", function() { return WallBlock; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Entity\", function() { return Entity; });\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./errors */ \"./src/errors.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ \"./src/util.js\");\n\n\n\nclass Ray extends Phaser.Line {\n  constructor(x, y, angle, length) {\n    super();\n    this.fromAngle(x, y, angle, length);\n    this.origin = new Phaser.Point(this.start.x, this.start.y);\n    this.collisions = [];\n  }\n}\n\nclass PlanarObject extends Phaser.Line {\n  /*\n  Native renderable object (the equivalent of a line in the Euclidean plane)\n\n  @param {number} x - Initial starting x-axis coordinate\n  @param {number} y - Initial starting y-axis coordinate\n  @param {number} x2 - Initial ending x-axis coordinate\n  @param {number} y2 - Initial ending y-axis coordinate\n  @param {Object} [options={}] - Additional PlanarObject options\n  @param {number} [options.height=1] - Initial height of object (relative to the projected height of the object)\n  @param {String} [options.texture=null] - Image key referencing the cached texture (must be preloaded into the cache)\n  @param {Color} [options.color=new Color(255,255,255,1)] - Color object of the object (given a texture is not present)\n    // NOTE: It is not recommended to use colors of very high intensity, such as rgb(255,255,0), nor those of very low intensity, such as rgb(5,5,0)\n    // NOTE: but rather shades such as rgb(230,230,0).\n    // NOTE: This is because with colors of very high or low intensity, opacity will often not be perceivable as it either brightens or darkens the color.\n\n  @param {Boolean} [options.render=true] - Boolean regarding whether or not the object will be rendered\n  */\n  constructor(raycaster, x, y, x2, y2, options = {}) {\n    super(x, y, x2, y2);\n    this.raycaster = raycaster;\n\n    this.updateFrame = null;\n    this.renderFrame = null;\n\n    this.options = {\n      height: 1,\n      texture: null,\n      color: new _util__WEBPACK_IMPORTED_MODULE_1__[\"Color\"](255, 255, 255, 1),\n      render: true,\n    };\n    Object.keys(options).forEach((key) => {\n      if (Object.prototype.hasOwnProperty.call(this.options, key)) {\n        this.options[key] = options[key];\n      }\n    });\n    // if (typeof this.options.color === \"string\") this.options.color = new Color(this.options.color); //TODO\n    if (this.options.texture instanceof String || typeof this.options.texture === 'string') {\n      this.options.texture = raycaster.create.texture(raycaster.getTextureData(this.options.texture));\n    }\n\n    const error = new _errors__WEBPACK_IMPORTED_MODULE_0__[\"BoundsError\"](`PlanarObject ${this.toString()} instantiated outside of world bounds`);\n    if (\n      (raycaster.worldWidth !== null && Math.min(this.start.x, this.end.x) < 0)\n      || (raycaster.worldWidth !== null && Math.max(this.start.x, this.end.x) > raycaster.worldWidth)\n      || (raycaster.worldHeight !== null && Math.min(this.start.y, this.end.y) < 0)\n      || (raycaster.worldHeight !== null && Math.max(this.start.y, this.end.y) > raycaster.worldHeight)\n    ) {\n      throw error;\n    }\n  }\n\n  update() {\n    // Called on PlanarObject every update loop - should be overloaded to add additional functionality to custom objects\n    if (this.options.texture !== null) this.options.texture.update();\n    if (typeof this.updateFrame === 'function') this.updateFrame();\n  }\n\n  render() {\n    // Calls this.renderFrame every every render loop - renderFrame should be overloaded to add any render logic to the PlanarObject\n    if (typeof this.renderFrame === 'function') this.renderFrame();\n  }\n\n  toString() {\n    return `[${this.constructor.name}(${this.start.x},${this.start.y},${this.end.x},${this.end.y})]`;\n  }\n}\n\nclass Wall extends PlanarObject {\n  constructor(raycaster, x, y, x2, y2, options = {}) {\n    super(raycaster, x, y, x2, y2, options);\n  }\n}\n\n/**\n * Helper function that constructs a square of walls\n *\n * @returns Wall[] - Constructed walls in the order \"top, right, bottom, left\"\n */\nfunction WallBlock(raycaster, x, y, x2, y2, WallType, options = {}) {\n  return [\n    // eslint-disable-next-line new-cap\n    new WallType(raycaster, x, y, x2, y, options),\n    new WallType(raycaster, x, y, x, y2, options),\n    new WallType(raycaster, x, y2, x2, y2, options),\n    new WallType(raycaster, x2, y, x2, y2, options),\n  ];\n}\n\n\nclass EntitySprite extends Phaser.Sprite {\n  constructor(raycaster, x, y, key) {\n    if (typeof key === 'undefined' || key === null) {\n      const graphics = new Phaser.Graphics(raycaster.debugInstance, 0, 0);\n      const rad = 3.5;\n      graphics.beginFill(0xff0000);\n      graphics.drawCircle(0, 0, rad * 2);\n      graphics.lineStyle(2, 0xff00ff, 1);\n      graphics.moveTo(0, 0);\n      graphics.lineTo(rad * 5, 0);\n      graphics.lineStyle(1, 0xffff00, 1);\n      graphics.beginFill(0xffff00);\n      // graphics.drawTriangle([new Phaser.Point(0,-rad),new Phaser.Point(0,rad-1),new Phaser.Point(rad*4,0)]);\n      // eslint-disable-next-line no-param-reassign\n      key = graphics.generateTexture();\n    }\n    super(raycaster.debugInstance, x, y, key);\n    this.raycaster = raycaster;\n    this.raycaster.debugInstance.physics.arcade.enable(this);\n    this.anchor.setTo(0.5, 0.5);\n    raycaster.debugInstance.add.existing(this);\n  }\n\n  move(lookSpeed, speed) {\n    // console.log(this.angle);\n    const vel = this.raycaster.debugInstance.physics.arcade.velocityFromAngle(this.angle, speed);\n    this.body.velocity.x += vel.x;\n    this.body.velocity.y += vel.y;\n  }\n}\n\nfunction scale(num, inMin, inMax, outMin, outMax) {\n  return (num - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;\n}\n\nclass Entity extends PlanarObject {\n  /*\n  Native renderable object with a camera and built-in movement functionality\n\n  @param {number} x - Initial x-axis coordinate\n  @param {number} y - Initial y-axis coordinate\n  @param {number} width - Width of the Entity\n  @param {number} height - Height of the Entity\n  @param {Boolean} hasCamera - When false, the Entity will cast out 0 rays\n  @param {Object} data - Data regarding the behavior of the Entity\n  @param {number} data.fov - Fov in degrees of Entity (<=0 if the Entity does not cast rays)\n  @param {number} data.speed - Speed of Entity in pixels per (second squared)\n  @param {number} data.lookSpeed - Speed at which Entity turns in degrees/radians per second squared (varies depending on version of Phaser)\n  @param {Phaser.Game} game - Instance of game that the Entity will store for use when rendering and performing other operations\n  @param {Object} [options={}] - Additional PLanarObject options\n  @param {String} options.color - Color object of the Entity (given a texture is not present)\n  @param {Boolean} options.render - Boolean regarding whether or not the Entity will be rendered\n  @param {Boolean} [options.useMouse=false] - Boolean regarding whether or not the object will hook into mouse on instantiation\n  @param {number} [angle=0] - Initial angle that the Entity faces\n  */\n  constructor(raycaster, x, y, width, hasCamera, data, game, options = { useMouse: false }, angle = 0) {\n    super(raycaster, x, y, x + width, y, options);\n    // this.rotate(angle,true);\n    this.game = game;\n    this.hasCamera = hasCamera;\n    this.data = data;\n    this.fov = data.fov;\n    this.speed = data.speed;\n    this.lookSpeed = data.lookSpeed;\n\n\n    this.drawFov = true;\n    this.drawCollision = true;\n\n    this.sprite = new EntitySprite(raycaster, (this.start.x + this.end.x) / 2, (this.start.y + this.end.y) / 2);\n    this.sprite.angle = angle;\n    this.rays = [];\n\n    this.setupMouse(this.game);\n    if (options.useMouse) {\n      this.startMouse(this.game);\n    } else {\n      this.stopMouse(this.game);\n    }\n\n    delete options.useMouse;\n  }\n\n  castRays() {\n    if (!this.hasCamera) return;\n    this.rays.length = 0; // empty ray array\n\n    // distToProjSurface = total_rays/2 / tan(half_of_fov_in_rad)\n    const distToProjSurface = (this.raycaster.totalRays / 2) / Math.tan((this.fov / 2).toRad());\n    for (let x = 0; x < this.raycaster.totalRays; x++) {\n      let angle = Math.atan((x - (this.raycaster.totalRays / 2)) / distToProjSurface);\n      angle += (this.sprite.angle).toRad();\n      const ray = new Ray(this.sprite.body.center.x, this.sprite.body.center.y, angle, this.raycaster.renderDistance);\n      this.rays.push(ray);\n    }\n  }\n\n  setupMouse() {\n    this.game.canvas.addEventListener('mousedown', () => { Object(_util__WEBPACK_IMPORTED_MODULE_1__[\"requestPointerLock\"])(this.game); }, this);\n    this.game.input.addMoveCallback((pointer, x, y, click) => { this.mouseMove(this.game, pointer, x, y, click); }, this);\n  }\n\n  startMouse() {\n    this.game.input.mouse.start();\n  }\n\n  stopMouse() {\n    this.game.input.mouse.stop();\n  }\n\n\n  // eslint-disable-next-line\n  mouseMove(pointer, x, y, click) {\n    // Should be overloaded to add functionality to mouse\n    // Should only be used in non split screen games\n  }\n\n  turn(horiz, mult) {\n    const ang = horiz * this.lookSpeed * mult;\n    // this.rotate(ang,true);\n    // this.sprite.angle = this.angle;\n    this.sprite.body.angularVelocity = ang;\n\n    this.center();\n  }\n\n  move(horiz, vert) {\n    let ang = this.sprite.angle;\n    let oldAng = this.sprite.angle;\n    if (horiz > 0) {\n      ang += 270;\n    } else if (horiz < 0) {\n      ang -= 90;\n    }\n    const speed = this.speed * (horiz + vert);\n    this.sprite.angle = ang;\n    this.sprite.move(this.lookSpeed, speed);\n    this.sprite.angle = oldAng;\n    this.center();\n  }\n\n  center() {\n    this.centerOn(this.sprite.body.center.x, this.sprite.body.center.y);\n  }\n\n  renderSky(color) {\n    // eslint-disable-next-line no-param-reassign\n    if (typeof color === 'undefined') color = new _util__WEBPACK_IMPORTED_MODULE_1__[\"Color\"](99, 185, 255, 1);\n\n    const ctx = this.game.canvas.getContext('2d');\n    ctx.beginPath();\n    ctx.fillStyle = color.toCSSString();\n    ctx.fillRect(0, 0, this.game.world.width, this.game.world.height / 2);\n  }\n\n  renderGround(color) {\n    // eslint-disable-next-line no-param-reassign\n    if (typeof color === 'undefined') color = new _util__WEBPACK_IMPORTED_MODULE_1__[\"Color\"](226, 226, 226, 1);\n\n    const ctx = this.game.canvas.getContext('2d');\n    ctx.beginPath();\n    ctx.fillStyle = color.toCSSString();\n    ctx.fillRect(0, this.game.world.height / 2, this.game.world.width, this.game.world.height / 2);\n  }\n\n  renderView() {\n    const ctx = this.game.canvas.getContext('2d');\n    const drawTimes = [];\n    const drawColumn = (column, color) => {\n      ctx.beginPath();\n      ctx.fillStyle = color.toCSSString();\n      ctx.fillRect(column.x, column.y, column.width, column.height);\n    };\n    this.rays.forEach((ray, i) => {\n      // eslint-disable-next-line max-len\n      const collisions = ray.collisions.slice().sort((c1, c2) => Math.sqrt(((c2.p.x - ray.origin.x) ** 2) + ((c2.p.y - ray.origin.y) ** 2)) - Math.sqrt(((c1.p.x - ray.origin.x) ** 2) + ((c1.p.y - ray.origin.y) ** 2)));\n      if (!this.raycaster.variableHeight) {\n        for (let m = 0; m < collisions.length; m++) {\n          const col = collisions[m];\n          col.renderThisFrame = true;\n          if (m > 0) {\n            const prevCol = collisions[m - 1];\n            if (col.obj.options.color.a === 1) {\n              prevCol.renderThisFrame = false;\n            }\n          }\n        }\n      }\n      for (let n = 0; n < collisions.length; n++) {\n        const col = collisions[n];\n        if (!this.raycaster.variableHeight && col.renderThisFrame === false) {\n          continue;\n        }\n        const collision = col.p;\n        const collisionObject = col.obj;\n\n        const { texture } = col.obj.options;\n\n\n        const rayLen = this.rays.length;\n        const width = Math.ceil(this.game.world.width / rayLen);\n        // console.log(width);\n        const dx = collision.x - ray.origin.x;\n        const dy = collision.y - ray.origin.y;\n        const distance = Math.sqrt((dx * dx) + (dy * dy));\n        const projHeight = distance * Math.cos((Math.atan2(dy, dx) - this.sprite.angle.toRad()));\n        const actualHeight = collisionObject.options.height;\n\n\n        const { color } = collisionObject.options;\n\n        const x = Math.floor((i) * (this.game.world.width / rayLen));\n\n        const projectedHeight = (this.game.world.height / (projHeight / this.fov));\n        const height = 2 * actualHeight * (projectedHeight / 2);\n        const y = (this.game.world.height / 2) - ((height) - (projectedHeight / 2));\n\n        const column = new Phaser.Rectangle(\n          x, // x\n          y, // y\n          width, // width\n          height, // height\n        );\n\n        if (texture !== null) {\n          const textureData = texture;\n\n          const image = textureData.getCurrentFrame();\n          if (image === undefined) {\n            drawColumn(column, color);\n            continue;\n          }\n\n          const distanceFromStart = Math.sqrt(((collision.x - collisionObject.start.x) ** 2) + ((collision.y - collisionObject.start.y) ** 2));\n          const pixelColumn = scale(distanceFromStart, 0, collisionObject.length, 0, image.width);\n          // console.log(image.width,image.height);\n          const imageHeight = image.height;\n\n          const t1 = Date.now();\n\n          ctx.drawImage(\n            image, // image\n            pixelColumn, // imageX\n            0, // imageY\n            1, // imageWidth\n            imageHeight, // imageHeight\n            column.x, // canvasX\n            column.y, // canvasY\n            column.width, // imageScaleWidth\n            column.height, // imageScaleHeight\n          );\n          drawTimes.push(Date.now() - t1);\n        } else {\n          drawColumn(column, color);\n        }\n      }\n    });\n  }\n}\n\nEntity.MOUSE_TURN_MULT = 1 / 4;\nEntity.KEYBOARD_TURN_MULT = 1.25;\n\n\n//# sourceURL=webpack://Raycaster/./src/objects.js?");

/***/ }),

/***/ "./src/texture.js":
/*!************************!*\
  !*** ./src/texture.js ***!
  \************************/
/*! exports provided: TextureData, Texture */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TextureData\", function() { return TextureData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Texture\", function() { return Texture; });\n/* harmony import */ var _external_gifuct_js_min__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./external/gifuct-js.min */ \"./src/external/gifuct-js.min.js\");\n/* harmony import */ var _external_gifuct_js_min__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_external_gifuct_js_min__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction GIFFrame(frame) {\n  const c = document.createElement('canvas');\n  c.width = frame.dims.width;\n  c.height = frame.dims.height;\n  const ctx = c.getContext('2d');\n  const imageData = ctx.createImageData(c.width, c.height);\n  imageData.data.set(frame.patch);\n  ctx.putImageData(imageData, 0, 0);\n\n  const img = new Image();\n  img.src = c.toDataURL();\n  img.frameLength = frame.delay;\n  return img;\n}\n\nclass TextureData {\n  constructor(key, path) {\n    this.key = key;\n    this.path = path;\n    this.frames = [];\n    this.loaded = false;\n  }\n\n  load(data, options = {}) {\n    return new Promise((resolve, reject) => {\n      const url = URL.createObjectURL(data);\n      if (/.*\\.gif/.test(this.path)) {\n        // gif\n        const reader = new FileReader();\n        reader.onload = () => {\n          const arrayBuffer = reader.result;\n          const time = Date.now();\n          // eslint-disable-next-line\n          const gif = new GIF(arrayBuffer);\n          console.log(Date.now() - time);\n          const frames = gif.decompressFrames(true);\n          if ('alpha' in options && !options.alpha) {\n            frames.forEach((f) => {\n              if (f.disposalType === 1) {\n                for (let i = 0; i < f.patch.length; i++) {\n                  if (f.patch[i] === 0) {\n                    f.patch[i] = 0;\n                  }\n                }\n              }\n            });\n          }\n          this.frames.push(...frames.map(f => GIFFrame(f)));\n          this.loaded = true;\n          URL.revokeObjectURL(url);\n          resolve();\n        };\n        reader.readAsArrayBuffer(data);\n      } else if (/.*(\\.mp4|\\.m4a|\\.m4p|\\.m4b|\\.m4r|\\.m4v)/.test(this.path)) {\n        // mp4\n        const video = document.createElement('video');\n        video.src = url;\n        video.autoplay = true;\n        video.loop = true;\n        video.onloadedmetadata = () => {\n          this.loaded = true;\n          video.width = video.videoWidth;\n          video.height = video.videoHeight;\n          // document.body.appendChild(video);\n          URL.revokeObjectURL(url);\n          resolve();\n        };\n        this.frames.push(video);\n      } else {\n        const image = new Image();\n        image.src = url;\n        image.onload = () => {\n          this.loaded = true;\n          URL.revokeObjectURL(url);\n          resolve();\n        };\n        image.onerror = () => {\n          this.loaded = true;\n          reject(new Error(`Failed to load texture '${this.key}'`));\n          URL.revokeObjectURL(url);\n        };\n        this.frames.push(image);\n      }\n    });\n  }\n}\n\nclass Texture {\n  constructor(textureData) {\n    this.textureData = textureData;\n    this.key = textureData.key;\n    this.path = textureData.path;\n    this.frames = textureData.frames;\n    this._currentFrame = 0;\n    this.elapsed = 0;\n    this.prevTime = null;\n  }\n\n  update() {\n    const currentFrame = this.getCurrentFrame();\n    // console.log(this.frames);\n    if (this.textureData.loaded && currentFrame.frameLength !== undefined) {\n      const currentTime = Date.now();\n      if (this.prevTime === null) {\n        this.prevTime = currentTime;\n      } else {\n        const elapsed = currentTime - this.prevTime;\n        this.elapsed += elapsed;\n        if (this.elapsed >= currentFrame.frameLength) {\n          this.elapsed = 0;\n          this.playNextFrame();\n        }\n        this.prevTime = currentTime;\n      }\n    }\n  }\n\n  playNextFrame() {\n    this._currentFrame++;\n    if (this._currentFrame >= this.frames.length) {\n      this._currentFrame = 0;\n    }\n  }\n\n  getCurrentFrame() {\n    return this.frames[this._currentFrame];\n  }\n}\n\n\n//# sourceURL=webpack://Raycaster/./src/texture.js?");

/***/ }),

/***/ "./src/util.js":
/*!*********************!*\
  !*** ./src/util.js ***!
  \*********************/
/*! exports provided: rgbToHex, Color, requestPointerLock, MapBuilder, intersect */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rgbToHex\", function() { return rgbToHex; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Color\", function() { return Color; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"requestPointerLock\", function() { return requestPointerLock; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MapBuilder\", function() { return MapBuilder; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"intersect\", function() { return intersect; });\nfunction rgbToHex(r, g, b) {\n  return (\n    (1 << 24) // eslint-disable-line no-bitwise\n    + (r << 16) // eslint-disable-line no-bitwise\n    + (g << 8) // eslint-disable-line no-bitwise\n    + b\n  ).toString(16).slice(1);\n}\n\nclass Color {\n  constructor(r, g, b, a) {\n    this.r = r;\n    this.g = g;\n    this.b = b;\n    this.a = a;\n  }\n\n  toHex() {\n    return parseInt(rgbToHex(this.r, this.g, this.b), 16);\n  }\n\n  toCSSString() {\n    return `rgba(${this.r},${this.g},${this.b},${this.a})`;\n  }\n}\n\nfunction requestPointerLock(game) {\n  game.input.mouse.requestPointerLock();\n}\n\n/*\n  Data map is in the format:\n[\n  [\n    [2, 1, 0],\n    [1, 1, 0],\n    [1, 0, 2]\n  ],\n  {\n    0: {\n      object: Wall,\n      arguments: [{height:2}]\n    },\n    1: {\n      object: Wall,\n      arguments: [{texture:'foo'}]\n    },\n    2: {\n      object: CustomWall,\n      arguments: []\n    },\n  }\n]\nNOTE: Values in first array may also be arrays in the format of [value, arguments] to override the predefined arguments for said value.\nNOTE: This format also inherently supports other data types such as strings instead of numbers to serve as instances. This may be more clear if desired.\nNOTE: Arguments passed to each class reference will go:\n  \"(raycaster instance, x1, y1, x2, y2, ...args)\"\n  If the class instance's constructor doesn't comply with this format, you may instead pass in a helper function to construct the instance:\n    [\n      0: {\n        helper: function(x1, y1, x2, y2) {\n          return new CustomWall(x1, y1, x2, y2, {texture:'bar'})\n        }\n      }\n    ]\n*/\nconst MapBuilder = {\n  build(raycaster, dataMap, xDimensions, yDimensions) {\n    const map = [];\n    const width = raycaster.worldWidth / xDimensions;\n    const height = raycaster.worldHeight / yDimensions;\n    for (let yInd = 0; yInd < dataMap[0].length; yInd++) {\n      for (let xInd = 0; xInd < dataMap[0][yInd].length; xInd++) {\n        let type = dataMap[0][yInd][xInd];\n        let object;\n        const x1 = width * xInd;\n        const x2 = x1 + width;\n        const y1 = height * yInd;\n        const y2 = y1 + height;\n\n\n        let args;\n\n        if (Array.isArray(type)) {\n          [type, ...args] = type;\n        }\n\n        const data = dataMap[1][type];\n\n        if (typeof args === 'undefined') args = Object.prototype.hasOwnProperty.call(data, 'arguments') ? data.arguments : [];\n\n        if (Object.prototype.hasOwnProperty.call(data, 'helper')) {\n          object = data.helper(raycaster, x1, y1, x2, y2);\n        } else {\n          // eslint-disable-next-line new-cap\n          object = new data.object(raycaster, x1, y1, x2, y2, ...args);\n        }\n        map.push(object);\n        // super(raycaster,x,y,x2,y2,height,options);\n      }\n    }\n    return map;\n  },\n  loadFromFile(file) {\n    // TODO\n\n  },\n};\n\nfunction intersect(x1, y1, x2, y2, x3, y3, x4, y4) {\n  // Check if none of the lines are of length 0\n  if ((x1 === x2 && y1 === y2) || (x3 === x4 && y3 === y4)) {\n    return false;\n  }\n\n  const denominator = ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));\n\n  // Lines are parallel\n  if (denominator === 0) {\n    return false;\n  }\n\n  const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator;\n  const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator;\n\n  // is the intersection along the segments\n  if (ua < 0 || ua > 1 || ub < 0 || ub > 1) {\n    return false;\n  }\n\n  // Return a object with the x and y coordinates of the intersection\n  const x = x1 + ua * (x2 - x1);\n  const y = y1 + ua * (y2 - y1);\n\n  return { x, y };\n}\n\n\n//# sourceURL=webpack://Raycaster/./src/util.js?");

/***/ })

/******/ });