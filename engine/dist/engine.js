var Raycaster =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/exports.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/worker-loader/dist/workers/InlineWorker.js":
/*!*****************************************************************!*\
  !*** ./node_modules/worker-loader/dist/workers/InlineWorker.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// http://stackoverflow.com/questions/10343913/how-to-create-a-web-worker-from-a-string\n\nvar URL = window.URL || window.webkitURL;\n\nmodule.exports = function (content, url) {\n  try {\n    try {\n      var blob;\n\n      try {\n        // BlobBuilder = Deprecated, but widely implemented\n        var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;\n\n        blob = new BlobBuilder();\n\n        blob.append(content);\n\n        blob = blob.getBlob();\n      } catch (e) {\n        // The proposed API\n        blob = new Blob([content]);\n      }\n\n      return new Worker(URL.createObjectURL(blob));\n    } catch (e) {\n      return new Worker('data:application/javascript,' + encodeURIComponent(content));\n    }\n  } catch (e) {\n    if (!url) {\n      throw Error('Inline worker is not supported');\n    }\n\n    return new Worker(url);\n  }\n};\n\n//# sourceURL=webpack://Raycaster/./node_modules/worker-loader/dist/workers/InlineWorker.js?");

/***/ }),

/***/ "./src/camera.js":
/*!***********************!*\
  !*** ./src/camera.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Camera; });\n/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color */ \"./src/color.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ \"./src/util.js\");\n/* harmony import */ var _geom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./geom */ \"./src/geom.js\");\n\r\n\r\n\r\n/**\r\n * Ray class used for performing logic\r\n *\r\n */\r\nclass Ray extends _geom__WEBPACK_IMPORTED_MODULE_2__[\"Line\"] {\r\n  constructor(x, y, angle, length) {\r\n    super();\r\n    this.fromAngle(x, y, angle, length);\r\n    this.origin = new _geom__WEBPACK_IMPORTED_MODULE_2__[\"Point\"](this.start.x, this.start.y);\r\n    this.collisions = [];\r\n  }\r\n}\r\n\r\n/**\r\n * Native camera object used to cast rays.\r\n *\r\n * @param {PlanarObject} object - Object that the camera is attached to. May be reassigned at any point.\r\n * @param {number} [fov=100] - Fov in degrees of the camera\r\n * @param {number} [turnSpeed=3.14159] - Turn speed of the camera in radians per seconds.\r\n *\r\n */\r\nclass Camera {\r\n  constructor(object, game, fov, turnSpeed) {\r\n    this.object = object;\r\n    this.game = game;\r\n    this.fov = typeof fov !== \"undefined\" ? fov : 100;\r\n    this.turnSpeed = typeof turnSpeed !== \"undefined\" ? turnSpeed : Math.PI;\r\n\r\n    this._rays = [];\r\n\r\n    /* Offsets the axis positions of the camera from the owner object. */\r\n    // 2d context\r\n    this.xOffset = 0;\r\n    this.zOffset = 0;\r\n    // 3d context\r\n    // yOffset is at the top of the object\r\n    this.yOffset = this.object.varHeight;\r\n\r\n    // May set to render the ground and sky custom colors\r\n    this.groundColor = undefined;\r\n    this.skyColor = undefined;\r\n  }\r\n\r\n  calculateRayCollision() {\r\n    let obj = this.object;\r\n    this._rays.forEach((ray) => {\r\n      this.object.raycaster.objects.forEach((colObj) => {\r\n        if (colObj === obj || !colObj.visible) return;\r\n        const intersection = Object(_util__WEBPACK_IMPORTED_MODULE_1__[\"intersect\"])(ray.start.x, ray.start.y, ray.end.x, ray.end.y, colObj.start.x, colObj.start.y, colObj.end.x, colObj.end.y);\r\n        if (intersection) ray.collisions.push({ p: intersection, obj: colObj });\r\n        // console.log(ray.start.x, ray.start.y, ray.end.x, ray.end.y, colObj.start.x, colObj.start.y, colObj.end.x, colObj.end.y);\r\n      });\r\n    });\r\n  }\r\n\r\n  castRays() {\r\n    this._rays.length = 0; // empty the ray array\r\n\r\n    // distToProjSurface = total_rays/2 / tan(half_of_fov_in_rad)\r\n    const distToProjSurface = (this.object.raycaster.totalRays / 2) / Math.tan((this.fov / 2).toRad());\r\n    for (let x = 0; x < this.object.raycaster.totalRays; x++) {\r\n      let angle = Math.atan((x - (this.object.raycaster.totalRays / 2)) / distToProjSurface);\r\n      angle += (this.object.angle.toDeg()+90).toRad();\r\n      const ray = new Ray(this.object.midpoint.x + this.xOffset, this.object.midpoint.y + this.zOffset, angle, this.object.raycaster.renderDistance);\r\n      this._rays.push(ray);\r\n    }\r\n  }\r\n\r\n  render() {\r\n    const ctx = this.game.canvas.getContext('2d');\r\n\r\n    this.renderGround(ctx, this.groundColor);\r\n    this.renderSky(ctx, this.skyColor);\r\n    this.renderView(ctx);\r\n  }\r\n\r\n  renderSky(ctx, color) {\r\n    // eslint-disable-next-line no-param-reassign\r\n    if (typeof color === 'undefined') color = new _color__WEBPACK_IMPORTED_MODULE_0__[\"default\"](99, 185, 255, 1);\r\n\r\n    ctx.beginPath();\r\n    ctx.fillStyle = color.toCSSString();\r\n    ctx.fillRect(0, 0, this.object.raycaster.instanceWidth, this.object.raycaster.instanceHeight / 2);\r\n  }\r\n\r\n  renderGround(ctx, color) {\r\n    // eslint-disable-next-line no-param-reassign\r\n    if (typeof color === 'undefined') color = new _color__WEBPACK_IMPORTED_MODULE_0__[\"default\"](226, 226, 226, 1);\r\n\r\n    ctx.beginPath();\r\n    ctx.fillStyle = color.toCSSString();\r\n    ctx.fillRect(0, this.object.raycaster.instanceHeight / 2, this.object.raycaster.instanceWidth, this.object.raycaster.instanceHeight / 2);\r\n  }\r\n\r\n  renderView(ctx) {\r\n    this.castRays();\r\n    this.calculateRayCollision();\r\n    const drawTimes = [];\r\n    const drawColumn = (column, color) => {\r\n      ctx.beginPath();\r\n      ctx.fillStyle = color.toCSSString();\r\n      ctx.fillRect(column.x, column.y, column.width, column.height);\r\n    };\r\n    this._rays.forEach((ray, i) => {\r\n      // eslint-disable-next-line max-len\r\n      const collisions = ray.collisions;\r\n      collisions.forEach((collision) => {\r\n        const distance = Math.sqrt(((collision.p.x - ray.origin.x) ** 2) + ((collision.p.y - ray.origin.y) ** 2));\r\n        collision.distance = distance;\r\n      });\r\n      collisions.sort((c1, c2) => c2.distance - c1.distance);\r\n      if (!this.object.raycaster.variableHeight) {\r\n        for (let m = 0; m < collisions.length; m++) {\r\n          const col = collisions[m];\r\n          col.renderThisFrame = true;\r\n          if (m > 0) {\r\n            const prevCol = collisions[m - 1];\r\n            if (col.obj.color.a === 1) {\r\n              prevCol.renderThisFrame = false;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      for (let n = 0; n < collisions.length; n++) {\r\n        const col = collisions[n];\r\n        if (!this.object.raycaster.variableHeight && col.renderThisFrame === false) {\r\n          continue;\r\n        }\r\n        const collision = col.p;\r\n        const collisionObject = col.obj;\r\n\r\n        const texture = col.obj.texture;\r\n\r\n\r\n        const rayLen = this._rays.length;\r\n        const width = Math.ceil(this.object.raycaster.instanceWidth / rayLen);\r\n        // console.log(width);\r\n        const dx = collision.x - ray.origin.x;\r\n        const dy = collision.y - ray.origin.y;\r\n        // const distance = Math.sqrt((dx * dx) + (dy * dy));\r\n        const distance = col.distance;\r\n        // const ang = (Math.atan2(dy, dx) - (this.object.angle.toDeg()-90).toRad());\r\n        const ang = (ray.angle - (this.object.angle-(Math.PI/2)));\r\n        const projHeight = distance * Math.cos(ang);\r\n        const actualHeight = this.object.raycaster.variableHeight ? collisionObject.varHeight : 1;\r\n\r\n\r\n        const color = collisionObject.color;\r\n\r\n        const x = Math.floor((i) * (this.object.raycaster.instanceWidth / rayLen));\r\n\r\n        const projectedHeight = (this.object.raycaster.instanceHeight / (projHeight / this.fov));\r\n        // console.log(this.object.raycaster.instanceHeight);\r\n        // const projectedHeight = this.object.raycaster.instanceHeight/(projHeight/this.fov);\r\n        const height = 2 * actualHeight * (projectedHeight / 2);\r\n        // Change (this.object.raycaster.instanceHeight * 2) to (this.object.raycaster.instanceHeight * verticalAngleInDegrees/360) to look up and down. Maxes at height * 360 and height * 0;\r\n        //    NOTE: Skybox/ground won't work with this method and I don't know a fix. Probably some fairly basic math.\r\n      // Change this.object.varHeight to higher or lower to move on the z-axis.\r\n        // Once at a value > 1, variable height must be enabled for it to render properly.\r\n        const y = (this.object.raycaster.instanceHeight * (this.object.verticalAngle/(Math.PI*2))) - ((projectedHeight) * (this.object.yPos3D + this.yOffset));\r\n        const column = new _geom__WEBPACK_IMPORTED_MODULE_2__[\"Rect\"](\r\n          x, // x\r\n          y, // y\r\n          width, // width\r\n          height, // height\r\n        );\r\n\r\n        if (texture !== null) {\r\n          const textureData = texture;\r\n\r\n          const image = textureData.getCurrentFrame();\r\n          let angle = col.obj.angle.toDeg();\r\n          // if (angle < 0) {\r\n            // angle = (360) + angle;\r\n          // }\r\n          if (image === undefined) {\r\n            drawColumn(column, color);\r\n          } else {\r\n            const distanceFromStart = Math.sqrt(((collision.x - collisionObject.start.x) ** 2) + ((collision.y - collisionObject.start.y) ** 2));\r\n            const pixelColumn = Object(_util__WEBPACK_IMPORTED_MODULE_1__[\"scale\"])(distanceFromStart, 0, collisionObject.length, 0, image.width);\r\n            // console.log(image.width,image.height);\r\n            const imageHeight = image.height;\r\n\r\n            const t1 = Date.now();\r\n\r\n            ctx.drawImage(\r\n              image, // image\r\n              pixelColumn, // imageX\r\n              0, // imageY\r\n              1, // imageWidth\r\n              imageHeight, // imageHeight\r\n              column.x, // canvasX\r\n              column.y, // canvasY\r\n              column.width, // imageScaleWidth\r\n              column.height, // imageScaleHeight\r\n            );\r\n            drawTimes.push(Date.now() - t1);\r\n          }\r\n        } else {\r\n          drawColumn(column, color);\r\n        }\r\n      }\r\n    });\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://Raycaster/./src/camera.js?");

/***/ }),

/***/ "./src/color.js":
/*!**********************!*\
  !*** ./src/color.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Color; });\n/**\r\n * Native color class used in engine, in the format rgba.\r\n * Note: Alpha is supported, but, when used in large quantities, may result in significant loss of performance.\r\n */\r\nclass Color {\r\n  constructor(r, g, b, a=1) {\r\n    this.r = r;\r\n    this.g = g;\r\n    this.b = b;\r\n    this.a = a;\r\n  }\r\n\r\n  /**\r\n   * Utility function used to convert values r, g, b to a CSS hex string\r\n   *    NOTE: Ignores the alpha layer.\r\n   *\r\n   */\r\n  toHexString() {\r\n    return \"#\" + (\r\n      (1 << 24) // eslint-disable-line no-bitwise\r\n      + (this.r << 16) // eslint-disable-line no-bitwise\r\n      + (this.g << 8) // eslint-disable-line no-bitwise\r\n      + this.b\r\n    ).toString(16).slice(1);\r\n  }\r\n\r\n  toHexInt() {\r\n    return parseInt(this.toHexString(this.r, this.g, this.b, this.a).slice(1), 16);\r\n  }\r\n\r\n  toCSSString() {\r\n    return `rgba(${this.r},${this.g},${this.b},${this.a})`;\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://Raycaster/./src/color.js?");

/***/ }),

/***/ "./src/engine.js":
/*!***********************!*\
  !*** ./src/engine.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Raycaster; });\n/* harmony import */ var _texture__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./texture */ \"./src/texture.js\");\n/* harmony import */ var _objects__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./objects */ \"./src/objects.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors */ \"./src/errors.js\");\n/* harmony import */ var _keyboard__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./keyboard */ \"./src/keyboard.js\");\n/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./color */ \"./src/color.js\");\n\r\n\r\n\r\n\r\n\r\n\r\nclass Raycaster {\r\n  /*\r\n  Main class used to perform update logic and handle the game state\r\n\r\n  @param {number} width - Width in pixels of game instances\r\n  @param {number} height - Height in pixels of game instances\r\n  @param {string | HTMlElement} parent - Parent element that game instances will be created within\r\n  @param {Object | null} state - Takes a state object used to manage game instances.\r\n  @param {number} [renderDistance=100000] - Max length in pixels of rays that Entities cast out\r\n    Has infinitesimal effect on performance\r\n  @param {number} [totalRays=null] - Total amount of rays that are cast out by an Entity\r\n    Recommended to be left as null as it uses it will use the width of the game instances\r\n    Can be reduced or increased to increase or reduce fps respectively\r\n  @param {boolean} [debug=false] - Sets if the debugger is shown.\r\n  @param {Object} [options={}] - Additional optional parameters to speed up initialization of object\r\n  @param {number} [options.worldWidth=null] - If not null, the world will have defined width. Required along with options.worldHeight in order to use any map related utilities.\r\n  @param {number} [options.worldHeight=null] - If not null, the world will have defined height. Required along with options.worldWidth in order to use any map related utilities.\r\n  @param {Boolean} [options.variableHeight=false] - Sets if PlanarObjects not of type Entity may have variable height\r\n    Must be set in order for variable height to render properly or else taller objects will not be rendered when behind shorter ones\r\n    // NOTE: Variable height results in some loss of performance\r\n  @param {Object | null} [options.assetLoadState=null] - Takes a state object. Loads all assets synchronously before proceeding to the preload state. If null, loads assets asynchronously.\r\n  @param {Boolean} [options.automaticallyResize] - Maintains the sizes of game instances in proportion to the window's size.\r\n  */\r\n  constructor(canvasWidth, canvasHeight, parent, state=null, renderDistance = 1e7, totalRays = null, debug = false, options = {}) {\r\n    this.options = {\r\n      worldWidth: null,\r\n      worldHeight: null,\r\n      variableHeight: false,\r\n      assetLoadState: null,\r\n      automaticallyResize: false\r\n    };\r\n    Object.keys(options).forEach((key) => {\r\n      if (Object.prototype.hasOwnProperty.call(this.options, key)) {\r\n        this.options[key] = options[key];\r\n      }\r\n    });\r\n    Object.keys(this.options).forEach((key) => {\r\n      this[key] = this.options[key];\r\n    });\r\n    delete this.options;\r\n\r\n    this.renderDistance = renderDistance;\r\n    this.debugMode = debug;\r\n\r\n    this.totalRays = typeof totalRays === 'undefined' || totalRays === null || totalRays === undefined ? canvasWidth : totalRays;\r\n\r\n\r\n    this.create = new Raycaster.ObjectFactory(this);\r\n\r\n    this.renderFPS = debug;\r\n    this.debugObjects = [];\r\n    this.instanceWidth = canvasWidth;\r\n    this.instanceHeight = canvasHeight;\r\n    this.instanceParent = parent;\r\n    this.gameInstances = [];\r\n    this.objects = [];\r\n    this.running = false;\r\n\r\n    this.prevTime = performance.now();\r\n\r\n    this._textures = [];\r\n\r\n    this.keyboard = new _keyboard__WEBPACK_IMPORTED_MODULE_3__[\"default\"]();\r\n\r\n    this.mainGame = state;\r\n\r\n    if (this.automaticallyResize) {\r\n      this.aspectRatio = {\r\n        x: this.instanceWidth / document.body.clientWidth,\r\n        y: this.instanceHeight / document.body.clientHeight\r\n      }\r\n    }\r\n\r\n    window.addEventListener('resize', (e) => {\r\n      if (this.automaticallyResize) {\r\n        this.gameInstances.forEach(game => {\r\n          game.scale.setGameSize(this.aspectRatio.x * document.body.clientWidth, this.aspectRatio.y * document.body.clientHeight);\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  init() {\r\n    this.running = true;\r\n\r\n\r\n    if (this.worldWidth !== null && this.worldHeight !== null) {\r\n      this.addGameObjects(\r\n        this.create.wallBlock(0,0,this.worldWidth,this.worldHeight, _objects__WEBPACK_IMPORTED_MODULE_1__[\"Wall\"],{color:new _color__WEBPACK_IMPORTED_MODULE_4__[\"default\"](255,255,255,1)})\r\n      );\r\n    }\r\n\r\n    if (this.mainGame !== null) {\r\n      // Main state is passed the raycaster instance if needed\r\n      let mainState = new this.mainGame(this);\r\n      mainState.preload()\r\n      this.gameInstances.forEach((game) => {\r\n        let parentElement = this.instanceParent === '' ? null : document.getElementById(this.instanceParent);\r\n          if (parentElement === null) parentElement = document.body;\r\n          parentElement.appendChild(game.canvas);\r\n          game.state = new game.State(game);\r\n          game.state.preload();\r\n      });\r\n      mainState.create();\r\n      this.gameInstances.forEach((game) => {\r\n          game.state.create();\r\n      });\r\n      const update = () => {\r\n          const delta = this._update();\r\n          mainState.update(delta);\r\n          this.gameInstances.forEach((game) => {\r\n              game.time.totalElapsed += delta;\r\n              game.time.prevDelta = game.time.delta;\r\n              game.time.delta = delta;\r\n              game.state.update(delta);\r\n          });\r\n          mainState.render();\r\n          this.gameInstances.forEach((game) => {\r\n              game.state.render(delta);\r\n              game.time.totalFrames++;\r\n              this.renderDebugMode();\r\n          });\r\n          window.requestAnimationFrame(update);\r\n      }\r\n      window.requestAnimationFrame(update);\r\n      return mainState;\r\n    }\r\n    else {\r\n      // Only one game instance (hopefully)\r\n      const game = this.gameInstances[0];\r\n      let parentElement = this.instanceParent === '' ? null : document.getElementById(this.instanceParent);\r\n      // If parent is empty or element doesn't exist append to body\r\n      if (parentElement === null) parentElement = document.body;\r\n      parentElement.appendChild(game.canvas);\r\n\r\n      let state = new game.State(game);\r\n      state.preload();\r\n      state.create();\r\n\r\n      const update = () => {\r\n        const delta = this._update();\r\n        game.time.totalElapsed += delta;\r\n        game.time.prevDelta = game.time.delta;\r\n        game.time.delta = delta;\r\n        state.update(delta);\r\n        state.render(delta);\r\n        this.renderDebugMode();\r\n        game.time.totalFrames++;\r\n        window.requestAnimationFrame(update);\r\n      }\r\n      window.requestAnimationFrame(update);\r\n      return state;\r\n    }\r\n  }\r\n\r\n  getTextureData(key) {\r\n    const data = this._textures[key];\r\n    if (data === undefined) {\r\n      throw new _errors__WEBPACK_IMPORTED_MODULE_2__[\"CacheError\"](`Texture \"${key}\" does not exist in the cache.`);\r\n      return false;\r\n    }\r\n    else {\r\n      return data;\r\n    }\r\n  }\r\n\r\n  async loadTexture(key, path, options = {}) {\r\n    /*\r\n    Loads a texture into the cache.\r\n\r\n    @param {String} key - Key stored in cache to fetch TextureData\r\n    @param {String} path - File path or URI that is loaded as a texture\r\n    @param {Object} options - Array of additional arguments\r\n    @param {Boolean} options.alpha - (ONLY SUPPORTS .GIFS WITH FRAMES OF DISPOSAL TYPE 1) If false, the alpha layer of the .gif will be removed\r\n\r\n    @returns {Promise.<String>} key - Key used to instantiate the texture from the cache.\r\n    */\r\n\r\n    const texture = new _texture__WEBPACK_IMPORTED_MODULE_0__[\"TextureData\"](key);\r\n\r\n    this._textures.hasOwnProperty(key) && console.warn(new _errors__WEBPACK_IMPORTED_MODULE_2__[\"CacheError\"](`Texture ${key} was overwritten`));\r\n\r\n    this._textures[key] = texture;\r\n\r\n    await texture.load(path, options);\r\n\r\n    return texture;\r\n\r\n    // return key;\r\n  }\r\n\r\n  /**\r\n   * Create a raycaster game instance (rendering and logical space).\r\n   *\r\n   * @param {Object} state - A state constructor returning or containing methods `preload`, `create`, `update`, and `render.`\r\n   */\r\n  createGame(state) {\r\n    let canvas = document.createElement('canvas');\r\n    canvas.width = this.instanceWidth;\r\n    canvas.height = this.instanceHeight;\r\n    let game = this._createGameObject(state, canvas);\r\n    this.gameInstances.push(game);\r\n    return game;\r\n  }\r\n\r\n  _createGameObject(state, canvas) {\r\n    return {\r\n      canvas: canvas,\r\n      time: {\r\n        totalFrames: 0,\r\n        totalElapsed: 0,\r\n        delta: 0,\r\n        prevDelta: 0,\r\n        _fpsCounter: 0,\r\n        _smoothing: 0.1,\r\n        _weightRatio: 0.1,\r\n        _prevFps: 0,\r\n        get fps() {\r\n          let delta = this.delta * (1 - this._weightRatio) + this.prevDelta * this._weightRatio;\r\n          delta = (this.prevDelta * this._smoothing) + (delta * (1 - this._smoothing));\r\n          const fps = 1000 / delta;\r\n          this._prevFps = fps;\r\n          return fps;\r\n        }\r\n      },\r\n      State: state\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Adds a game object (inherits PlanarObject) to the raycaster instance\r\n   */\r\n  addGameObject(obj) {\r\n    this.objects.push(obj);\r\n  }\r\n\r\n  /**\r\n   * Recursively adds all game objects inside of `objs` to the raycaster instance\r\n   */\r\n  addGameObjects(objs) {\r\n    objs.forEach((obj) => {\r\n      if (Array.isArray(obj)) {\r\n        this.addGameObjects(obj);\r\n      } else {\r\n        this.addGameObject(obj);\r\n      }\r\n    });\r\n  }\r\n\r\n  removeGameObject(obj) {\r\n    this.objects = this.objects.filter(o => o !== obj);\r\n  }\r\n\r\n  _update() {\r\n    const newTime = performance.now();\r\n    const delta = newTime - this.prevTime;\r\n    this.prevTime = newTime;\r\n\r\n    // Runs time logic still to prevent something like tabbing out from resulting in huge time delta when tabbing back in.\r\n\r\n    if (!this.running) return;\r\n\r\n    this.objects.forEach((obj) => {\r\n      obj.preUpdate();\r\n      obj.update(delta);\r\n    });\r\n\r\n    return delta;\r\n\r\n  }\r\n\r\n\r\n\r\n  renderDebugMode() {\r\n    if (this.renderFPS) {\r\n      this.gameInstances.forEach((instance) => {\r\n        let ctx = instance.canvas.getContext('2d');\r\n          ctx.font = \"20px Arial\";\r\n          ctx.fillStyle = \"#000000\";\r\n\r\n          let fps;\r\n          instance.time._fpsCounter += instance.time.delta;\r\n          if (instance.time._fpsCounter >= 250) {\r\n            fps = instance.time.fps.toFixed(0);\r\n            instance.time._fpsCounter = 0;\r\n          }\r\n          else {\r\n            fps = instance.time._prevFps.toFixed(0);\r\n          }\r\n          ctx.fillText(\"FPS: \"+fps, 20, 35);\r\n\r\n          ctx.font = \"14px Arial\";\r\n          ctx.fillStyle = \"#000000\";\r\n          this.debugObjects.forEach((obj, i) => {\r\n            const objRepr = `${obj.constructor.name}(x: ${Math.round(obj.x)}, z: ${Math.round(obj.y)}, y: ${Math.round(obj.yPos3D)})`;\r\n            ctx.fillText(objRepr, 20, 70+(i*30));\r\n          });\r\n      });\r\n    }\r\n    // this.objects.forEach((obj) => {\r\n    // });\r\n\r\n  }\r\n}\r\n\r\nRaycaster.ObjectFactory = function ObjectFactory(raycaster) {\r\n  return {\r\n    planarObject(...args) {\r\n      return new _objects__WEBPACK_IMPORTED_MODULE_1__[\"PlanarObject\"](raycaster, ...args);\r\n    },\r\n\r\n    wall(...args) {\r\n      return new _objects__WEBPACK_IMPORTED_MODULE_1__[\"Wall\"](raycaster, ...args);\r\n    },\r\n\r\n    wallBlock(...args) {\r\n      return Object(_objects__WEBPACK_IMPORTED_MODULE_1__[\"wallBlock\"])(raycaster, ...args);\r\n    },\r\n\r\n    entity(...args) {\r\n      return new _objects__WEBPACK_IMPORTED_MODULE_1__[\"Wall\"](raycaster, ...args);\r\n    },\r\n\r\n    texture(...args) {\r\n      return new _texture__WEBPACK_IMPORTED_MODULE_0__[\"Texture\"](...args);\r\n    },\r\n\r\n  };\r\n};\r\n\r\n// eslint-disable-next-line no-extend-native\r\nNumber.prototype.toRad = function toRad() {\r\n  return this * (Math.PI / 180);\r\n};\r\n\r\n// eslint-disable-next-line no-extend-native\r\nNumber.prototype.toDeg = function toDeg() {\r\n  return this * (180 / Math.PI);\r\n};\r\n\r\n// eslint-disable-next-line no-extend-native\r\nNumber.prototype.clamp = function clamp(min, max) {\r\n  return Math.min(Math.max(this, min), max);\r\n};\r\n\n\n//# sourceURL=webpack://Raycaster/./src/engine.js?");

/***/ }),

/***/ "./src/errors.js":
/*!***********************!*\
  !*** ./src/errors.js ***!
  \***********************/
/*! exports provided: BoundsError, LoadError, CacheError */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BoundsError\", function() { return BoundsError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LoadError\", function() { return LoadError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CacheError\", function() { return CacheError; });\nclass BoundsError extends Error {\r\n  constructor(...args) {\r\n    super(...args);\r\n    this.name = this.constructor.name;\r\n  }\r\n}\r\nclass LoadError extends Error {\r\n  constructor(...args) {\r\n    super(...args);\r\n    this.name = this.constructor.name;\r\n  }\r\n}\r\nclass CacheError extends Error {\r\n  constructor(...args) {\r\n    super(...args);\r\n    this.name = this.constructor.name;\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://Raycaster/./src/errors.js?");

/***/ }),

/***/ "./src/exports.js":
/*!************************!*\
  !*** ./src/exports.js ***!
  \************************/
/*! exports provided: Engine, Texture, MapBuilder, Minimap, Wall, Camera, constructWallBlock, PlanarObject, Color, Key, Point, Line, Rect, Error */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./engine */ \"./src/engine.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Engine\", function() { return _engine__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; });\n\n/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color */ \"./src/color.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Color\", function() { return _color__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; });\n\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ \"./src/util.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MapBuilder\", function() { return _util__WEBPACK_IMPORTED_MODULE_2__[\"MapBuilder\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Minimap\", function() { return _util__WEBPACK_IMPORTED_MODULE_2__[\"Minimap\"]; });\n\n/* harmony import */ var _texture__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./texture */ \"./src/texture.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Texture\", function() { return _texture__WEBPACK_IMPORTED_MODULE_3__[\"Texture\"]; });\n\n/* harmony import */ var _camera__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./camera */ \"./src/camera.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Camera\", function() { return _camera__WEBPACK_IMPORTED_MODULE_4__[\"default\"]; });\n\n/* harmony import */ var _keyboard__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./keyboard */ \"./src/keyboard.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Key\", function() { return _keyboard__WEBPACK_IMPORTED_MODULE_5__[\"Key\"]; });\n\n/* harmony import */ var _geom__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./geom */ \"./src/geom.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Point\", function() { return _geom__WEBPACK_IMPORTED_MODULE_6__[\"Point\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Line\", function() { return _geom__WEBPACK_IMPORTED_MODULE_6__[\"Line\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Rect\", function() { return _geom__WEBPACK_IMPORTED_MODULE_6__[\"Rect\"]; });\n\n/* harmony import */ var _objects__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./objects */ \"./src/objects.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Wall\", function() { return _objects__WEBPACK_IMPORTED_MODULE_7__[\"Wall\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"constructWallBlock\", function() { return _objects__WEBPACK_IMPORTED_MODULE_7__[\"wallBlock\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PlanarObject\", function() { return _objects__WEBPACK_IMPORTED_MODULE_7__[\"PlanarObject\"]; });\n\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./errors */ \"./src/errors.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"Error\", function() { return _errors__WEBPACK_IMPORTED_MODULE_8__; });\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\n//# sourceURL=webpack://Raycaster/./src/exports.js?");

/***/ }),

/***/ "./src/geom.js":
/*!*********************!*\
  !*** ./src/geom.js ***!
  \*********************/
/*! exports provided: Point, Line, Rect */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Point\", function() { return Point; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Line\", function() { return Line; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Rect\", function() { return Rect; });\nclass Point {\r\n  constructor(x, y) {\r\n    this.x = x;\r\n    this.y = y;\r\n  }\r\n  /**\r\n   * Rotates the point about an anchor\r\n   *\r\n   * @param {number} x - Anchor's x-axis coordinate\r\n   * @param {number} y - Anchor's y-axis coordinate\r\n   * @param {number} angle - Angle in radians\r\n   */\r\n  rotate(x, y, angle) {\r\n    // const length = Math.sqrt(((this.x - x)**2), ((this.y - y)**2));\r\n    this.x -= x;\r\n    this.y -= y;\r\n    let s = Math.sin(angle);\r\n    let c = Math.cos(angle);\r\n    let tx = c * this.x - s * this.y;\r\n    let ty = s * this.x + c * this.y;\r\n    this.x = x + tx;\r\n    this.y = y + ty;\r\n    // this.x = length * Math.sin(angle);\r\n    // this.y = length * Math.cos(angle);\r\n    // console.log(this.x,this.y, angle, length);\r\n    // angle = angle + Math.atan2(this.y - y, this.x - x);\r\n    // this.x = x + (length * Math.cos(angle));\r\n    // this.y = y + (length * Math.sin(angle));\r\n  }\r\n}\r\nclass Line {\r\n  constructor(x1, y1, x2, y2) {\r\n    this.start = new Point(x1, y1);\r\n    this.end = new Point(x2, y2);\r\n  }\r\n  /**\r\n   * Sets the line to a new line created from length and an angle\r\n   *\r\n   * @param {number} x - Starting x-axis coordinate of the line\r\n   * @param {number} y - Starting y-axis coordinate of the line\r\n   * @param {number} angle - Angle in radians that the line is created from\r\n   * @param {number} length - Length of the line\r\n   */\r\n  fromAngle(x, y, angle, length) {\r\n    let start = new Point(\r\n      x,\r\n      y\r\n    );\r\n    let end = new Point(\r\n      x + (length * Math.cos(angle)),\r\n      y + (length * Math.sin(angle))\r\n    );\r\n    this.start = start;\r\n    this.end = end;\r\n  }\r\n  /**\r\n   * Sets the new coordinates of the Line\r\n   *\r\n   * @param {number} x1 - Starting x-axis coordinate\r\n   * @param {number} y1 - Starting y-axis coordinate\r\n   * @param {number} x2 - Ending x-axis coordinate\r\n   * @param {number} y2 - Ending y-axis coordinate\r\n   *\r\n   */\r\n  setTo(x1, y1, x2, y2) {\r\n    this.start = new Point(\r\n      x1,\r\n      y1\r\n    );\r\n    this.end = new Point(\r\n      x2,\r\n      y2\r\n    );\r\n  }\r\n  /**\r\n   * Rotates the line about its midpoint by a given amount\r\n   *\r\n   * @param {number} angle - Angle to rotate the line by\r\n   * @param {boolean} degrees - If true, angle will treated as if it is in degrees (defaults to radians)\r\n   */\r\n  rotate(angle, degrees=false) {\r\n    if (degrees) angle = angle.toRad();\r\n    const midpoint = this.midpoint;\r\n    const cx = midpoint.x;\r\n    const cy = midpoint.y;\r\n    this.start.rotate(cx, cy, angle);\r\n    this.end.rotate(cx, cy, angle);\r\n    // this.fromAngle((this.start.x+this.end.x)/2, (this.start.y+this.end.y)/2, angle, this.length);\r\n  }\r\n  /**\r\n   * Shorthand for calculating the angle of the line\r\n   */\r\n  get angle() {\r\n    return Math.atan2((this.end.y-this.start.y),(this.end.x-this.start.x));\r\n  }\r\n  /**\r\n   * Shorthand for applying the distance formula to the line\r\n   */\r\n  get length() {\r\n    return Math.sqrt(((this.end.x-this.start.x)**2) + ((this.end.y-this.start.y)**2));\r\n  }\r\n  /**\r\n   * Alias of Line::midpoint\r\n   */\r\n  get center() {\r\n    return this.midpoint;\r\n  }\r\n  /**\r\n   * Getter shorthand for calculating the midpoint of the Line\r\n   */\r\n  get midpoint() {\r\n    return new Point(\r\n      (this.end.x + this.start.x) / 2,\r\n      (this.end.y + this.start.y) / 2\r\n    );\r\n  }\r\n  /**\r\n   * Shorthand for the x-axis midpoint coordinate of the Line\r\n   */\r\n  get x() {\r\n    return this.center.x;\r\n  }\r\n  /**\r\n   * Shorthand for the y-axis midpoint coordinate of the Line\r\n   */\r\n  get y() {\r\n    return this.center.y;\r\n  }\r\n}\r\nclass Rect {\r\n  constructor(x,  y, width, height) {\r\n    this.x = x;\r\n    this.y = y;\r\n    this.width = width;\r\n    this.height = height;\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://Raycaster/./src/geom.js?");

/***/ }),

/***/ "./src/keyboard.js":
/*!*************************!*\
  !*** ./src/keyboard.js ***!
  \*************************/
/*! exports provided: default, Key */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Keyboard; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Key\", function() { return Key; });\nclass Keyboard {\r\n  constructor() {\r\n    this.enabled = true;\r\n    this._keysDown = {};\r\n    window.onkeydown = (e) => {\r\n      // Store relevant properties from the event\r\n      this._keysDown[e.keyCode] = {\r\n        location: e.location,\r\n      };\r\n    }\r\n    window.onkeyup = (e) => {\r\n      this._keysDown[e.keyCode] = false;\r\n    }\r\n  }\r\n  isDown(keyCode) {\r\n    return !this.enabled ? false : this._keysDown[keyCode];\r\n  }\r\n  /**\r\n   * Add a key object\r\n   *\r\n   * @param {int} keyCode - The key code for the key. For ease of use, the Key class contains mappings for all these keys.\r\n   */\r\n  addKey(keyCode) {\r\n    return new Key(this, keyCode);\r\n  }\r\n  addKeys(keyCodes) {\r\n    keyCodes.forEach((keyCode) => this.addKey(keyCode));\r\n  }\r\n}\r\n\r\nclass Key {\r\n  constructor(keyboard, keyCode) {\r\n    this.keyboard = keyboard;\r\n    this.keyCode = keyCode;\r\n  }\r\n  get isDown() {\r\n    return this.keyboard.isDown(this.keyCode);\r\n  }\r\n}\r\n\r\nKey.ZERO = 48;\r\nKey.ONE = 49;\r\nKey.TWO = 50;\r\nKey.THREE = 51;\r\nKey.FOUR = 52;\r\nKey.FIVE = 53;\r\nKey.SIX = 54;\r\nKey.SEVEN = 55;\r\nKey.EIGHT = 56;\r\nKey.NINE = 57;\r\nKey.A = 65;\r\nKey.ADD = 107;\r\nKey.ALT = 18;\r\nKey.B = 66;\r\nKey.BACKSPACE = 8;\r\nKey.BACK_SLASH = 220;\r\nKey.C = 67;\r\nKey.CAPS_LOCK = 20;\r\nKey.CLOSE_BRAKET = 221;\r\nKey.COMMA = 188;\r\nKey.CTRL = 17;\r\nKey.D = 68;\r\nKey.DASH = 189;\r\nKey.DECIMAL_POINT = 110;\r\nKey.DELETE = 46;\r\nKey.DIVIDE = 111;\r\nKey.DOWN_ARROW = 40;\r\nKey.E = 69;\r\nKey.END = 35;\r\nKey.ENTER = 13;\r\nKey.EQUAL_SIGN = 187;\r\nKey.ESCAPE = 27;\r\nKey.F = 70;\r\nKey.F1 = 112;\r\nKey.F2 = 113;\r\nKey.F3 = 114;\r\nKey.F4 = 115;\r\nKey.F5 = 116;\r\nKey.F6 = 117;\r\nKey.F7 = 118;\r\nKey.F8 = 119;\r\nKey.F9 = 120;\r\nKey.F10 = 121;\r\nKey.F11 = 122;\r\nKey.F12 = 123;\r\nKey.FORWARD_SLASH = 191;\r\nKey.G = 71;\r\nKey.GRAVE_ACCENT = 192;\r\nKey.H = 72;\r\nKey.HOME = 36;\r\nKey.I = 73;\r\nKey.INSERT = 45;\r\nKey.J = 74;\r\nKey.K = 75;\r\nKey.L = 76;\r\nKey.LEFT_ARROW = 37;\r\nKey.LEFT_WINDOW_KEY = 91;\r\nKey.M = 77;\r\nKey.MULTIPLY = 106;\r\nKey.N = 78;\r\nKey.NUMPAD_0 = 96;\r\nKey.NUMPAD_1 = 97;\r\nKey.NUMPAD_2 = 98;\r\nKey.NUMPAD_3 = 99;\r\nKey.NUMPAD_4 = 100;\r\nKey.NUMPAD_5 = 101;\r\nKey.NUMPAD_6 = 102;\r\nKey.NUMPAD_7 = 103;\r\nKey.NUMPAD_8 = 104;\r\nKey.NUMPAD_9 = 105;\r\nKey.NUM_LOCK = 144;\r\nKey.O = 79;\r\nKey.OPEN_BRACKET = 219;\r\nKey.P = 80;\r\nKey.PAGE_DOWN = 34;\r\nKey.PAGE_UP = 33;\r\nKey.PAUSE_BREAK = 19;\r\nKey.PERIOD = 190;\r\nKey.Q = 81;\r\nKey.R = 82;\r\nKey.RIGHT_ARROW = 39;\r\nKey.RIGHT_WINDOW_KEY = 92;\r\nKey.S = 83;\r\nKey.SCROLL_LOCK = 145;\r\nKey.SELECT_KEY = 93;\r\nKey.SEMI_COLON = 186;\r\nKey.SHIFT = 16;\r\nKey.SINGLE_QUOTE = 222;\r\nKey.SPACE = 32;\r\nKey.SUBTRACT = 109;\r\nKey.T = 84;\r\nKey.TAB = 9;\r\nKey.U = 85;\r\nKey.UP_ARROW = 38;\r\nKey.V = 86;\r\nKey.W = 87;\r\nKey.X = 88;\r\nKey.Y = 89;\r\nKey.Z = 90;\r\n\n\n//# sourceURL=webpack://Raycaster/./src/keyboard.js?");

/***/ }),

/***/ "./src/objects.js":
/*!************************!*\
  !*** ./src/objects.js ***!
  \************************/
/*! exports provided: PlanarObject, Wall, wallBlock */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PlanarObject\", function() { return PlanarObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Wall\", function() { return Wall; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"wallBlock\", function() { return wallBlock; });\n/* harmony import */ var _camera__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./camera */ \"./src/camera.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors */ \"./src/errors.js\");\n/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./color */ \"./src/color.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util */ \"./src/util.js\");\n/* harmony import */ var _geom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./geom */ \"./src/geom.js\");\n\r\n\r\n\r\n\r\n\r\n\r\nclass PlanarObject extends _geom__WEBPACK_IMPORTED_MODULE_4__[\"Line\"] {\r\n  /*\r\n  Native renderable object (the equivalent of a line in the Euclidean plane)\r\n\r\n  @param {number} x - Initial starting x-axis coordinate\r\n  @param {number} y - Initial starting y-axis coordinate\r\n  @param {number} x2 - Initial ending x-axis coordinate\r\n  @param {number} y2 - Initial ending y-axis coordinate\r\n  @param {Object} [options={}] - Additional PlanarObject options\r\n  @param {Boolean} [options.collision=true] - Boolean regarding whether objects of type Entity will have movement blocked by the PlanarObject\r\n  @param {number} [options.height=1] - Initial height of object (relative to the projected height of the object)\r\n  @param {String} [options.texture=null] - Image key referencing the cached texture (must be preloaded into the cache)\r\n  @param {Color} [options.color=new Color(255,255,255,1)] - Color object of the object (given a texture is not present)\r\n    // NOTE: It is not recommended to use colors of very high intensity, such as rgb(255,255,0), nor those of very low intensity, such as rgb(5,5,0)\r\n    // NOTE: but rather shades such as rgb(230,230,0).\r\n    // NOTE: This is because with colors of very high or low intensity, opacity will often not be perceivable as it either brightens or darkens the color.\r\n\r\n  @param {Boolean} [options.render=true] - Boolean regarding whether or not the object will be rendered\r\n  */\r\n  constructor(raycaster, x, y, x2, y2, options = {}) {\r\n    super(x, y, x2, y2);\r\n    this.raycaster = raycaster;\r\n\r\n    this.camera = null;\r\n\r\n    this.options = {\r\n      collision: true,\r\n      varHeight: 1,\r\n      texture: null,\r\n      color: new _color__WEBPACK_IMPORTED_MODULE_2__[\"default\"](255, 255, 255, 1),\r\n      visible: true,\r\n    };\r\n\r\n    Object.keys(options).forEach((key) => {\r\n      if (Object.prototype.hasOwnProperty.call(this.options, key)) {\r\n        this.options[key] = options[key];\r\n      }\r\n    });\r\n    Object.keys(this.options).forEach((key) => {\r\n      this[key] = this.options[key];\r\n    });\r\n    delete this.options;\r\n\r\n    // if (typeof this.options.color === \"string\") this.options.color = new Color(this.options.color); //TODO\r\n    if (this.texture instanceof String || typeof this.texture === 'string') {\r\n      try {\r\n        this.texture = raycaster.create.texture(raycaster.getTextureData(this.texture));\r\n      }\r\n      catch (e) {\r\n        // Error is thrown if the texture does not exist in the cache. However, this should not halt the program.\r\n        console.warn(e);\r\n        this.texture = null;\r\n      }\r\n    }\r\n\r\n    // Experimental\r\n    this.verticalAngle = Math.PI;\r\n\r\n    /* Mass is used in the calculation of acceleration. It is not particularly relevant, but may be changed if desired. */\r\n    this.mass = 1;\r\n\r\n    /* Velocity is the rate of change of an object's position. */\r\n    this.velocity = {\r\n      x: 0,\r\n      z: 0,\r\n      y: 0\r\n    };\r\n    /* Terminal velocity is the maximum velocity an object can have. In the real world, it is caused due to resistance applied by a medium such as air. */\r\n    this.terminalVelocity = {\r\n      x: null,\r\n      z: null,\r\n      y: null\r\n    };\r\n    /* Friction is the will slow an object's velocity. It is a constant force applied to the object every physics loop. */\r\n    this.friction = {\r\n      x: 0,\r\n      z: 0,\r\n      y: 0\r\n    };\r\n\r\n    // Y-Axis position in the 3d plane.\r\n    this.yPos3D = 0;\r\n\r\n    const error = new _errors__WEBPACK_IMPORTED_MODULE_1__[\"BoundsError\"](`PlanarObject ${this.toString()} instantiated outside of world bounds`);\r\n    if (\r\n      (raycaster.worldWidth !== null && Math.min(this.start.x, this.end.x) < 0)\r\n      || (raycaster.worldWidth !== null && Math.max(this.start.x, this.end.x) > raycaster.worldWidth)\r\n      || (raycaster.worldHeight !== null && Math.min(this.start.y, this.end.y) < 0)\r\n      || (raycaster.worldHeight !== null && Math.max(this.start.y, this.end.y) > raycaster.worldHeight)\r\n    ) {\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Instantiate a camera on this object\r\n   *\r\n   */\r\n  addCamera(game, fov, turnSpeed) {\r\n    this.camera = new _camera__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this, game, fov, turnSpeed);\r\n  }\r\n\r\n  /**\r\n   * Sets up the mouse. Must be called before mouse will work.\r\n   */\r\n  setupMouse(game) {\r\n    game.canvas.addEventListener('mousedown', () => { Object(_util__WEBPACK_IMPORTED_MODULE_3__[\"requestPointerLock\"])(game); }, this);\r\n    game.input.addMoveCallback((pointer, x, y, click) => { this.mouseMove(game, pointer, x, y, click); }, this);\r\n  }\r\n\r\n  /**\r\n   * When called the mouse will begin to fire callbacks on mouse move\r\n   *\r\n   */\r\n  enableMouse(game) {\r\n    game.input.mouse.start();\r\n  }\r\n\r\n  /**\r\n   * When called the mouse will cease to fire callbacks on mouse move\r\n   *\r\n   */\r\n  disableMouse(game) {\r\n    game.input.mouse.stop();\r\n  }\r\n\r\n  // eslint-disable-next-line\r\n  mouseMove(pointer, x, y, click) {\r\n    // Should be overloaded to add functionality to mouse\r\n    // Should only be used in non split screen games\r\n  }\r\n\r\n  /**\r\n   * Turn the PlanarObject horizontally.\r\n   *\r\n   * @param {number} angle  - Sets the angle relative to the current angle in radians.\r\n   */\r\n  turnHorizontally(angle) {\r\n    this.rotate(angle);\r\n  }\r\n\r\n  /**\r\n   * Turn the PlanarObject vertically.\r\n   *\r\n   * @param {number} angle  - Sets the angle relative to the current angle in radians.\r\n   */\r\n  turnVertically(angle) {\r\n    this.verticalAngle += angle;\r\n  }\r\n\r\n  /**\r\n   * Sets the angle (absolute).\r\n   *\r\n   * @param {number} angle - The angle in radians.\r\n   */\r\n   setAngle(angle) {\r\n     this.rotate(angle-this.angle);\r\n   }\r\n\r\n  /**\r\n   * Method for moving the PlanarObject within a 2d context (x-axis and z-axis).\r\n   *\r\n   * @param {number} force - Amount of force applied to the PlanarObject.\r\n   * @param {number} horiz - Number of value either 1 or -1 to indicate strafing.\r\n   * @param {number} elapsed - Elapsed time since last frame in milliseconds.\r\n   */\r\n  move(force, horiz, elapsed) {\r\n    let ang = this.angle;\r\n    ang = Math.PI*2 - ang;\r\n    if (horiz === 1) {\r\n      ang += Math.PI/2;\r\n    }\r\n    else if (horiz === -1) {\r\n      ang -= Math.PI * (3/2);\r\n    }\r\n\r\n    let acceleration = force / this.mass;\r\n\r\n    // Angular velocity\r\n    this.velocity.x += acceleration * Math.sin(ang) * (elapsed/1000);\r\n    this.velocity.z += acceleration * Math.cos(ang) * (elapsed/1000);\r\n\r\n    // let x = speed * (Math.sin(ang));\r\n    // let y = speed * (Math.cos(ang));\r\n    // this.setTo(this.start.x+x,this.start.y+y,this.end.x+x,this.end.y+y);\r\n  }\r\n\r\n  /**\r\n   * Method for moving the PlanarObject along the y-axis within the 3d plane.\r\n   *    NOTE: The y-axis is relative to the unit height of all PlanarObjects.\r\n   *    NOTE: The camera is positioned at PlanarObject.yPos3D, which on default is the top of the PlanarObject.\r\n   *\r\n   * @param {number} force - Amount of force applied to the PlanarObject.\r\n   * @param {number} elapsed - Elapsed time since last frame in milliseconds.\r\n   */\r\n  moveY(force, elapsed) {\r\n    let acceleration = force / this.mass;\r\n    this.velocity.y += acceleration * (elapsed/1000);\r\n  }\r\n\r\n  handleCollision() {\r\n    // ifndef\r\n    if (!this.prevPos) {\r\n      this.prevPos = {\r\n        x: this.midpoint.x,\r\n        y: this.midpoint.y\r\n      };\r\n    }\r\n    let mid = this.midpoint;\r\n    const slope = [mid.y - this.prevPos.y, mid.x - this.prevPos.x];\r\n    let moveAngle = Math.atan2(slope[0],slope[1]).toDeg();\r\n    if (moveAngle < 0) moveAngle = 360 + moveAngle;\r\n    // console.log(moveAngle);\r\n    // console.log(this.sprite.body.velocity.x);\r\n\r\n    if (slope[0] !== 0 || slope[1] !== 0) {\r\n      for (let i=0;i<this.raycaster.objects.length;i++) {\r\n        let obj = this.raycaster.objects[i];\r\n        if (obj === this || !obj.collision) continue;\r\n        let intersection = Object(_util__WEBPACK_IMPORTED_MODULE_3__[\"intersect\"])(this.prevPos.x,this.prevPos.y,this.prevPos.x,mid.y,obj.start.x,obj.start.y,obj.end.x,obj.end.y);\r\n        let intersected = false;\r\n        if (intersection) {\r\n          intersected = true;\r\n          this.setTo(this.start.x,this.start.y - (mid.y-this.prevPos.y),this.end.x,this.end.y - (mid.y-this.prevPos.y));\r\n          // this.sprite.y = this.prevPos.y;\r\n\r\n        }\r\n        intersection = Object(_util__WEBPACK_IMPORTED_MODULE_3__[\"intersect\"])(this.prevPos.x,this.prevPos.y,mid.x,this.prevPos.y,obj.start.x,obj.start.y,obj.end.x,obj.end.y);\r\n        if (intersection) {\r\n          intersected = true;\r\n          this.setTo(this.start.x - (mid.x-this.prevPos.x),this.start.y,this.end.x - (mid.x-this.prevPos.x),this.end.y);\r\n          // this.sprite.x = this.prevPos.x;\r\n        }\r\n        // if (intersected) break;\r\n      }\r\n    }\r\n\r\n    this.prevPos = {\r\n      x: this.midpoint.x,\r\n      y: this.midpoint.y\r\n    };\r\n  }\r\n  /*\r\n  handleCollision() {\r\n    // ifndef\r\n    if (!this.prevPos) {\r\n      this.prevPos = {\r\n        start:{x:this.start.x,y:this.start.y},\r\n        end:{x:this.end.x,y:this.end.y}\r\n      };\r\n    }\r\n    Object.keys(this.prevPos).forEach((type) => {\r\n      let prevPos = this.prevPos[type];\r\n      // Generally bad. But fixed so it won't have any unexpected behavior.\r\n      let mid = this[type];\r\n      const slope = [mid.y - prevPos.y, mid.x - prevPos.x];\r\n      let moveAngle = Math.atan2(slope[0],slope[1]).toDeg();\r\n      if (moveAngle < 0) moveAngle = 360 + moveAngle;\r\n      // console.log(moveAngle);\r\n      // console.log(this.sprite.body.velocity.x);\r\n      if (slope[0] !== 0 || slope[1] !== 0) {\r\n        for (let i=0;i<this.raycaster.objects.length;i++) {\r\n          let obj = this.raycaster.objects[i];\r\n          if (obj === this || !obj.options.collision) continue;\r\n          let intersection = intersect(prevPos.x,prevPos.y,prevPos.x,mid.y,obj.start.x,obj.start.y,obj.end.x,obj.end.y);\r\n          let intersected = false;\r\n          if (intersection) {\r\n            intersected = true;\r\n            this.setTo(this.start.x,this.start.y - (mid.y-prevPos.y),this.end.x,this.end.y - (mid.y-prevPos.y));\r\n            // this.sprite.y = prevPos.y;\r\n          }\r\n          intersection = intersect(prevPos.x,prevPos.y,mid.x,prevPos.y,obj.start.x,obj.start.y,obj.end.x,obj.end.y);\r\n          if (intersection) {\r\n            intersected = true;\r\n            this.setTo(this.start.x - (mid.x-prevPos.x),this.start.y,this.end.x - (mid.x-prevPos.x),this.end.y);\r\n            // this.sprite.x = prevPos.x;\r\n          }\r\n          // if (intersected) break;\r\n        }\r\n      }\r\n    });\r\n    this.prevPos = {\r\n      start:{x:this.start.x,y:this.start.y},\r\n      end:{x:this.end.x,y:this.end.y}\r\n    };\r\n  }\r\n  */\r\n\r\n  /**\r\n   * Shorthand for setting the x-axis coordinate\r\n   *\r\n   */\r\n  setX(x) {\r\n    this.setTo(x,this.start.y,x+(this.end.x-this.start.x),this.end.y);\r\n  }\r\n\r\n  /**\r\n   * Shorthand for setting the z-axis coordinate\r\n   *\r\n   */\r\n  setZ(z) {\r\n    this.setTo(this.start.x,z,this.end.x,z+(this.end.y-this.start.y));\r\n  }\r\n\r\n\r\n  // These methods may be overloaded as long as super method is called\r\n\r\n  /**\r\n   * Called on PlanarObject every update loop, but before the Raycaster imposes any update logic.\r\n   *\r\n   * @param {number} elapsed - Time delta in milliseconds spanning the beginning of the last frame's update loop to the beginning of the current frame's update loop\r\n   */\r\n  preUpdate(elapsed) {\r\n    //Called on PlanarObject every update loop, but before the Raycaster imposes any update logic\r\n  }\r\n\r\n  /**\r\n   * Called on PlanarObject every update loop, but after the Raycaster imposes any update logic.\r\n   *\r\n   * @param {number} elapsed - Time delta in milliseconds spanning the beginning of the last frame's update loop to the beginning of the current frame's update loop\r\n   */\r\n  update(elapsed) {\r\n    if (this.texture !== null) this.texture.update();\r\n\r\n    /* Update position */\r\n\r\n    // Apply friction\r\n    let acc = {\r\n      x: this.friction.x / this.mass,\r\n      z: this.friction.z / this.mass,\r\n      y: this.friction.y / this.mass\r\n    };\r\n    for (let axis in this.velocity) {\r\n      let sign = Math.sign(this.velocity[axis]);\r\n      // Polish\r\n      if (axis !== \"y\") {\r\n        this.velocity[axis] -= sign * acc[axis] * (elapsed/1000);\r\n        if (Math.sign(this.velocity[axis]) !== sign) {\r\n          // If went past 0, set to 0.\r\n          this.velocity[axis] = 0;\r\n        }\r\n      }\r\n      else {\r\n        this.velocity[axis] -= acc[axis] * (elapsed/1000);\r\n      }\r\n\r\n      // Clamp the velocity to ensure that it does not exceed terminal velocity\r\n      if (this.terminalVelocity[axis] !== null) {\r\n        this.velocity[axis] = this.velocity[axis].clamp(-this.terminalVelocity[axis], this.terminalVelocity[axis]);\r\n      }\r\n    }\r\n\r\n    if (this.velocity.x !== 0 || this.velocity.z !== 0) {\r\n      let x = this.velocity.x * (elapsed/1000);\r\n      let z = this.velocity.z * (elapsed/1000);\r\n      this.setX(this.start.x+x);\r\n      this.setZ(this.start.y+z);\r\n      // this.setTo(this.start.x+x,this.start.y+z,this.end.x+x,this.end.y+z);\r\n\r\n      this.handleCollision();\r\n    }\r\n\r\n    if (this.velocity.y !== 0) {\r\n      let y = this.velocity.y * (elapsed/1000);\r\n      this.yPos3D += y;\r\n    }\r\n\r\n    // const gravitationalForce = 200;\r\n    // let yForce = gravitationalForce + this.yForce;\r\n    // if (this.yForce !== undefined) {\r\n    //   this.yForce *= .9;\r\n    //   this.z -= (yForce) * (elapsed/1000) * (elapsed/1000);\r\n    //   this.z = Math.max(1/2, this.z);\r\n    // }\r\n  }\r\n\r\n  /**\r\n   * Called on PLanarObject every every render loop, but after all update logic. Only called half as frequently as update methods.\r\n   *\r\n   * @param {number} elapsed - Time delta in milliseconds spanning the beginning of the last frame's update loop to the beginning of the current frame's update loop.\r\n   *    NOTE: Elapsed remains a constant throughout the frame. It will not differ between each frame-related function.\r\n   */\r\n  render(elapsed) {\r\n  }\r\n\r\n  toString() {\r\n    return `[${this.constructor.name}(${this.start.x},${this.start.y},${this.end.x},${this.end.y})]`;\r\n  }\r\n}\r\n\r\nclass Wall extends PlanarObject {\r\n  constructor(raycaster, x, y, x2, y2, options = {}) {\r\n    super(raycaster, x, y, x2, y2, options);\r\n  }\r\n}\r\n\r\n/**\r\n * Helper function that constructs a square of walls\r\n *\r\n * @returns Wall[] - Constructed walls in the order \"top, right, bottom, left\"\r\n */\r\nfunction wallBlock(raycaster, x, y, x2, y2, WallType, options = {}) {\r\n  return [\r\n    // top\r\n    new WallType(raycaster, x2, y, x, y, options),\r\n    // left\r\n    new WallType(raycaster, x, y, x, y2, options),\r\n    // bottom\r\n    new WallType(raycaster, x, y2, x2, y2, options),\r\n    // right\r\n    new WallType(raycaster, x2, y, x2, y2, options)\r\n  ];\r\n}\r\n\n\n//# sourceURL=webpack://Raycaster/./src/objects.js?");

/***/ }),

/***/ "./src/texture.js":
/*!************************!*\
  !*** ./src/texture.js ***!
  \************************/
/*! exports provided: TextureData, Texture */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TextureData\", function() { return TextureData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Texture\", function() { return Texture; });\n/* harmony import */ var _texture_worker_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./texture.worker.js */ \"./src/texture.worker.js\");\n/* harmony import */ var _texture_worker_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_texture_worker_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors */ \"./src/errors.js\");\n\r\n\r\n\r\nclass TextureData {\r\n  constructor(key) {\r\n    this.key = key;\r\n    this.frames = [];\r\n    this.loaded = false;\r\n  }\r\n\r\n  async load(url, options = {}) {\r\n    if (!new RegExp('^(?:[a-z]+:)?//', 'i').test(url)) {\r\n      url = window.location + url;\r\n    }\r\n    if (/.*\\.gif/.test(url)) {\r\n      /**\r\n       * GIF file\r\n       *\r\n       * @param {Object} options - Object of options.\r\n       * @param {Boolean} alpha - If false, the alpha layer will be stripped from the frames in the GIF. Recommended if variable height is disabled.\r\n       *    NOTE: This is applied on loading, and therefore it applies to all instances of the texture. Additionally, it means that it is static and may not be changed post-load.\r\n       *\r\n       */\r\n      const worker = new _texture_worker_js__WEBPACK_IMPORTED_MODULE_0___default.a();\r\n      worker.addEventListener('message', (e) => {\r\n        let msg = e.data;\r\n        // For some reason `ImageBitmap` objects lose all additional properties when sent over `postMessage`\r\n        msg.loadedFrames = msg.loadedFrames.map((f) => {\r\n          f.bmp.frameLength = f.frameLength;\r\n          return f.bmp;\r\n        })\r\n        if (msg.type === 'loadGIF') {\r\n          this.loaded = true;\r\n          this.frames = this.frames.concat(msg.loadedFrames);\r\n          return;\r\n        }\r\n      });\r\n      worker.postMessage({\r\n        type: 'loadGIF',\r\n        url: url,\r\n        options: options\r\n      })\r\n    } else if (/.*(\\.mp4|\\.m4a|\\.m4p|\\.m4b|\\.m4r|\\.m4v)/.test(url)) {\r\n      /**\r\n       * MP4 file\r\n       *\r\n       * @param {Object} options - Object of options.\r\n       * @param {Object} videoProps - Object of properties that will be applied to the video element on instantiation.\r\n       *\r\n       */\r\n      const video = document.createElement('video');\r\n      video.src = url;\r\n      video.muted = true; // Chrome 66+ requires that the video must be muted to autoplay without user interaction.\r\n      Object.entries(options.videoProps).forEach(([key, value]) => {\r\n        video[key] = value;\r\n      });\r\n      video.onloadedmetadata = () => {\r\n        console.log(1);\r\n        video.width = video.videoWidth;\r\n        video.height = video.videoHeight;\r\n        this.frames.push(video);\r\n        this.loaded = true;\r\n        video.play();\r\n        return;\r\n      };\r\n    } else {\r\n      /**\r\n       * Image file (duck test)\r\n\r\n       */\r\n      const image = new Image();\r\n      image.src = url;\r\n      image.onload = () => {\r\n        this.loaded = true;\r\n        return;\r\n      };\r\n      image.onerror = () => {\r\n        this.loaded = true;\r\n        throw new Error(`Failed to load texture \"${this.key}\" at url \"${url}\"`);\r\n      };\r\n      this.frames.push(image);\r\n    }\r\n  }\r\n}\r\n\r\nclass Texture {\r\n  constructor(textureData) {\r\n    this.textureData = textureData;\r\n    this.key = textureData.key;\r\n    this.loaded = textureData.loaded;\r\n    this.frames = textureData.frames;\r\n    this._currentFrame = 0;\r\n    this.elapsed = 0;\r\n    this.prevTime = null;\r\n  }\r\n\r\n  update() {\r\n    if (this.loaded !== this.textureData.loaded) {\r\n      this.loaded = this.textureData.loaded;\r\n      this.frames = this.textureData.frames.slice();\r\n    }\r\n\r\n    const currentFrame = this.getCurrentFrame();\r\n\r\n    if (currentFrame !== undefined) {\r\n      const currentTime = Date.now();\r\n      if (this.prevTime === null) {\r\n        this.prevTime = currentTime;\r\n      } else {\r\n        const elapsed = currentTime - this.prevTime;\r\n        this.elapsed += elapsed;\r\n        if (this.elapsed >= currentFrame.frameLength) {\r\n          this.elapsed = 0;\r\n          this.playNextFrame();\r\n        }\r\n        this.prevTime = currentTime;\r\n      }\r\n    }\r\n  }\r\n\r\n  playNextFrame() {\r\n    this._currentFrame++;\r\n    if (this._currentFrame >= this.frames.length) {\r\n      this._currentFrame = 0;\r\n    }\r\n  }\r\n\r\n  getCurrentFrame() {\r\n    return this.frames[this._currentFrame];\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://Raycaster/./src/texture.js?");

/***/ }),

/***/ "./src/texture.worker.js":
/*!*******************************!*\
  !*** ./src/texture.worker.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = function() {\n  return __webpack_require__(/*! !./node_modules/worker-loader/dist/workers/InlineWorker.js */ \"./node_modules/worker-loader/dist/workers/InlineWorker.js\")(\"/******/ (function(modules) { // webpackBootstrap\\n/******/ \\t// The module cache\\n/******/ \\tvar installedModules = {};\\n/******/\\n/******/ \\t// The require function\\n/******/ \\tfunction __webpack_require__(moduleId) {\\n/******/\\n/******/ \\t\\t// Check if module is in cache\\n/******/ \\t\\tif(installedModules[moduleId]) {\\n/******/ \\t\\t\\treturn installedModules[moduleId].exports;\\n/******/ \\t\\t}\\n/******/ \\t\\t// Create a new module (and put it into the cache)\\n/******/ \\t\\tvar module = installedModules[moduleId] = {\\n/******/ \\t\\t\\ti: moduleId,\\n/******/ \\t\\t\\tl: false,\\n/******/ \\t\\t\\texports: {}\\n/******/ \\t\\t};\\n/******/\\n/******/ \\t\\t// Execute the module function\\n/******/ \\t\\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\\n/******/\\n/******/ \\t\\t// Flag the module as loaded\\n/******/ \\t\\tmodule.l = true;\\n/******/\\n/******/ \\t\\t// Return the exports of the module\\n/******/ \\t\\treturn module.exports;\\n/******/ \\t}\\n/******/\\n/******/\\n/******/ \\t// expose the modules object (__webpack_modules__)\\n/******/ \\t__webpack_require__.m = modules;\\n/******/\\n/******/ \\t// expose the module cache\\n/******/ \\t__webpack_require__.c = installedModules;\\n/******/\\n/******/ \\t// define getter function for harmony exports\\n/******/ \\t__webpack_require__.d = function(exports, name, getter) {\\n/******/ \\t\\tif(!__webpack_require__.o(exports, name)) {\\n/******/ \\t\\t\\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\\n/******/ \\t\\t}\\n/******/ \\t};\\n/******/\\n/******/ \\t// define __esModule on exports\\n/******/ \\t__webpack_require__.r = function(exports) {\\n/******/ \\t\\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\\n/******/ \\t\\t\\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\\n/******/ \\t\\t}\\n/******/ \\t\\tObject.defineProperty(exports, '__esModule', { value: true });\\n/******/ \\t};\\n/******/\\n/******/ \\t// create a fake namespace object\\n/******/ \\t// mode & 1: value is a module id, require it\\n/******/ \\t// mode & 2: merge all properties of value into the ns\\n/******/ \\t// mode & 4: return value when already ns object\\n/******/ \\t// mode & 8|1: behave like require\\n/******/ \\t__webpack_require__.t = function(value, mode) {\\n/******/ \\t\\tif(mode & 1) value = __webpack_require__(value);\\n/******/ \\t\\tif(mode & 8) return value;\\n/******/ \\t\\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\\n/******/ \\t\\tvar ns = Object.create(null);\\n/******/ \\t\\t__webpack_require__.r(ns);\\n/******/ \\t\\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\\n/******/ \\t\\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\\n/******/ \\t\\treturn ns;\\n/******/ \\t};\\n/******/\\n/******/ \\t// getDefaultExport function for compatibility with non-harmony modules\\n/******/ \\t__webpack_require__.n = function(module) {\\n/******/ \\t\\tvar getter = module && module.__esModule ?\\n/******/ \\t\\t\\tfunction getDefault() { return module['default']; } :\\n/******/ \\t\\t\\tfunction getModuleExports() { return module; };\\n/******/ \\t\\t__webpack_require__.d(getter, 'a', getter);\\n/******/ \\t\\treturn getter;\\n/******/ \\t};\\n/******/\\n/******/ \\t// Object.prototype.hasOwnProperty.call\\n/******/ \\t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\\n/******/\\n/******/ \\t// __webpack_public_path__\\n/******/ \\t__webpack_require__.p = \\\"\\\";\\n/******/\\n/******/\\n/******/ \\t// Load entry module and return exports\\n/******/ \\treturn __webpack_require__(__webpack_require__.s = \\\"./src/texture.worker.js\\\");\\n/******/ })\\n/************************************************************************/\\n/******/ ({\\n\\n/***/ \\\"./src/external/gifuct-js.min.js\\\":\\n/*!***************************************!*\\\\\\n  !*** ./src/external/gifuct-js.min.js ***!\\n  \\\\***************************************/\\n/*! exports provided: window */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\neval(\\\"__webpack_require__.r(__webpack_exports__);\\\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\\\\\"window\\\\\\\", function() { return window; });\\\\nvar require;var require;const window = {};\\\\n(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\\\\\\\"function\\\\\\\"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error(\\\\\\\"Cannot find module '\\\\\\\"+o+\\\\\\\"'\\\\\\\");throw f.code=\\\\\\\"MODULE_NOT_FOUND\\\\\\\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\\\\\\\"function\\\\\\\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\\\\n\\\\n// Stream object for reading off bytes from a byte array\\\\n\\\\nfunction ByteStream(data){\\\\n\\\\tthis.data = data;\\\\n\\\\tthis.pos = 0;\\\\n}\\\\n\\\\n// read the next byte off the stream\\\\nByteStream.prototype.readByte = function(){\\\\n\\\\treturn this.data[this.pos++];\\\\n};\\\\n\\\\n// look at the next byte in the stream without updating the stream position\\\\nByteStream.prototype.peekByte = function(){\\\\n\\\\treturn this.data[this.pos];\\\\n};\\\\n\\\\n// read an array of bytes\\\\nByteStream.prototype.readBytes = function(n){\\\\n\\\\tvar bytes = new Array(n);\\\\n\\\\tfor(var i=0; i<n; i++){\\\\n\\\\t\\\\tbytes[i] = this.readByte();\\\\n\\\\t}\\\\n\\\\treturn bytes;\\\\n};\\\\n\\\\n// peek at an array of bytes without updating the stream position\\\\nByteStream.prototype.peekBytes = function(n){\\\\n\\\\tvar bytes = new Array(n);\\\\n\\\\tfor(var i=0; i<n; i++){\\\\n\\\\t\\\\tbytes[i] = this.data[this.pos + i];\\\\n\\\\t}\\\\n\\\\treturn bytes;\\\\n};\\\\n\\\\n// read a string from a byte set\\\\nByteStream.prototype.readString = function(len){\\\\n\\\\tvar str = '';\\\\n\\\\tfor(var i=0; i<len; i++){\\\\n\\\\t\\\\tstr += String.fromCharCode(this.readByte());\\\\n\\\\t}\\\\n\\\\treturn str;\\\\n};\\\\n\\\\n// read a single byte and return an array of bit booleans\\\\nByteStream.prototype.readBitArray = function(){\\\\n\\\\tvar arr = [];\\\\n\\\\tvar bite = this.readByte();\\\\n\\\\tfor (var i = 7; i >= 0; i--) {\\\\n\\\\t\\\\tarr.push(!!(bite & (1 << i)));\\\\n\\\\t}\\\\n\\\\treturn arr;\\\\n};\\\\n\\\\n// read an unsigned int with endian option\\\\nByteStream.prototype.readUnsigned = function(littleEndian){\\\\n\\\\tvar a = this.readBytes(2);\\\\n\\\\tif(littleEndian){\\\\n\\\\t\\\\treturn (a[1] << 8) + a[0];\\\\n\\\\t}else{\\\\n\\\\t\\\\treturn (a[0] << 8) + a[1];\\\\n\\\\t}\\\\n};\\\\n\\\\nmodule.exports = ByteStream;\\\\n},{}],2:[function(require,module,exports){\\\\n\\\\n// Primary data parsing object used to parse byte arrays\\\\n\\\\nvar ByteStream = require('./bytestream');\\\\n\\\\nfunction DataParser(data){\\\\n\\\\tthis.stream = new ByteStream(data);\\\\n\\\\t// the final parsed object from the data\\\\n\\\\tthis.output = {};\\\\n}\\\\n\\\\nDataParser.prototype.parse = function(schema){\\\\n\\\\t// the top level schema is just the top level parts array\\\\n\\\\tthis.parseParts(this.output, schema);\\\\n\\\\treturn this.output;\\\\n};\\\\n\\\\n// parse a set of hierarchy parts providing the parent object, and the subschema\\\\nDataParser.prototype.parseParts = function(obj, schema){\\\\n\\\\tfor(var i=0; i<schema.length; i++){\\\\n\\\\t\\\\tvar part = schema[i];\\\\n\\\\t\\\\tthis.parsePart(obj, part);\\\\n\\\\t}\\\\n};\\\\n\\\\nDataParser.prototype.parsePart = function(obj, part){\\\\n\\\\tvar name = part.label;\\\\n\\\\tvar value;\\\\n\\\\n\\\\t// make sure the part meets any parse requirements\\\\n\\\\tif(part.requires && ! part.requires(this.stream, this.output, obj)){\\\\n\\\\t\\\\treturn;\\\\n\\\\t}\\\\n\\\\n\\\\tif(part.loop){\\\\n\\\\t\\\\t// create a parse loop over the parts\\\\n\\\\t\\\\tvar items = [];\\\\n\\\\t\\\\twhile(part.loop(this.stream)){\\\\n\\\\t\\\\t\\\\tvar item = {};\\\\n\\\\t\\\\t\\\\tthis.parseParts(item, part.parts);\\\\n\\\\t\\\\t\\\\titems.push(item);\\\\n\\\\t\\\\t}\\\\n\\\\t\\\\tobj[name] = items;\\\\n\\\\t}else if(part.parts){\\\\n\\\\t\\\\t// process any child parts\\\\n\\\\t\\\\tvalue = {};\\\\n\\\\t\\\\tthis.parseParts(value, part.parts);\\\\n\\\\t\\\\tobj[name] = value;\\\\n\\\\t}else if(part.parser){\\\\n\\\\t\\\\t// parse the value using a parser\\\\n\\\\t\\\\tvalue = part.parser(this.stream, this.output, obj);\\\\n\\\\t\\\\tif(!part.skip){\\\\n\\\\t\\\\t\\\\tobj[name] = value;\\\\n\\\\t\\\\t}\\\\n\\\\t}else if(part.bits){\\\\n\\\\t\\\\t// convert the next byte to a set of bit fields\\\\n\\\\t\\\\tobj[name] = this.parseBits(part.bits);\\\\n\\\\t}\\\\n};\\\\n\\\\n// combine bits to calculate value\\\\nfunction bitsToNum(bitArray){\\\\n\\\\treturn bitArray.reduce(function(s, n) { return s * 2 + n; }, 0);\\\\n}\\\\n\\\\n// parse a byte as a bit set (flags and values)\\\\nDataParser.prototype.parseBits = function(details){\\\\n\\\\tvar out = {};\\\\n\\\\tvar bits = this.stream.readBitArray();\\\\n\\\\tfor(var key in details){\\\\n\\\\t\\\\tvar item = details[key];\\\\n\\\\t\\\\tif(item.length){\\\\n\\\\t\\\\t\\\\t// convert the bit set to value\\\\n\\\\t\\\\t\\\\tout[key] = bitsToNum(bits.slice(item.index, item.index + item.length));\\\\n\\\\t\\\\t}else{\\\\n\\\\t\\\\t\\\\tout[key] = bits[item.index];\\\\n\\\\t\\\\t}\\\\n\\\\t}\\\\n\\\\treturn out;\\\\n};\\\\n\\\\nmodule.exports = DataParser;\\\\n},{\\\\\\\"./bytestream\\\\\\\":1}],3:[function(require,module,exports){\\\\n\\\\n// a set of common parsers used with DataParser\\\\n\\\\nvar Parsers = {\\\\n\\\\t// read a byte\\\\n\\\\treadByte: function(){\\\\n\\\\t\\\\treturn function(stream){\\\\n\\\\t\\\\t\\\\treturn stream.readByte();\\\\n\\\\t\\\\t};\\\\n\\\\t},\\\\n\\\\t// read an array of bytes\\\\n\\\\treadBytes: function(length){\\\\n\\\\t\\\\treturn function(stream){\\\\n\\\\t\\\\t\\\\treturn stream.readBytes(length);\\\\n\\\\t\\\\t};\\\\n\\\\t},\\\\n\\\\t// read a string from bytes\\\\n\\\\treadString: function(length){\\\\n\\\\t\\\\treturn function(stream){\\\\n\\\\t\\\\t\\\\treturn stream.readString(length);\\\\n\\\\t\\\\t};\\\\n\\\\t},\\\\n\\\\t// read an unsigned int (with endian)\\\\n\\\\treadUnsigned: function(littleEndian){\\\\n\\\\t\\\\treturn function(stream){\\\\n\\\\t\\\\t\\\\treturn stream.readUnsigned(littleEndian);\\\\n\\\\t\\\\t};\\\\n\\\\t},\\\\n\\\\t// read an array of byte sets\\\\n\\\\treadArray: function(size, countFunc){\\\\n\\\\t\\\\treturn function(stream, obj, parent){\\\\n\\\\t\\\\t\\\\tvar count = countFunc(stream, obj, parent);\\\\n\\\\t\\\\t\\\\tvar arr = new Array(count);\\\\n\\\\t\\\\t\\\\tfor(var i=0; i<count; i++){\\\\n\\\\t\\\\t\\\\t\\\\tarr[i] = stream.readBytes(size);\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\treturn arr;\\\\n\\\\t\\\\t};\\\\n\\\\t}\\\\n};\\\\n\\\\nmodule.exports = Parsers;\\\\n},{}],4:[function(require,module,exports){\\\\n// export wrapper for exposing library\\\\n\\\\nvar GIF = window.GIF || {};\\\\n\\\\nGIF = require('./gif');\\\\n\\\\nwindow.GIF = GIF;\\\\n},{\\\\\\\"./gif\\\\\\\":5}],5:[function(require,module,exports){\\\\n\\\\n// object used to represent array buffer data for a gif file\\\\n\\\\nvar DataParser = require('../bower_components/js-binary-schema-parser/src/dataparser');\\\\nvar gifSchema = require('./schema');\\\\n\\\\nfunction GIF(arrayBuffer){\\\\n\\\\t// convert to byte array\\\\n\\\\tvar byteData = new Uint8Array(arrayBuffer);\\\\n\\\\tvar parser = new DataParser(byteData);\\\\n\\\\t// parse the data\\\\n\\\\tthis.raw = parser.parse(gifSchema);\\\\n\\\\n\\\\t// set a flag to make sure the gif contains at least one image\\\\n\\\\tthis.raw.hasImages = false;\\\\n\\\\tfor(var f=0; f<this.raw.frames.length; f++){\\\\n\\\\t\\\\tif(this.raw.frames[f].image){\\\\n\\\\t\\\\t\\\\tthis.raw.hasImages = true;\\\\n\\\\t\\\\t\\\\tbreak;\\\\n\\\\t\\\\t}\\\\n\\\\t}\\\\n}\\\\n\\\\n// process a single gif image frames data, decompressing it using LZW\\\\n// if buildPatch is true, the returned image will be a clamped 8 bit image patch\\\\n// for use directly with a canvas.\\\\nGIF.prototype.decompressFrame = function(index, buildPatch){\\\\n\\\\n\\\\t// make sure a valid frame is requested\\\\n\\\\tif(index >= this.raw.frames.length){ return null; }\\\\n\\\\n\\\\tvar frame = this.raw.frames[index];\\\\n\\\\tif(frame.image){\\\\n\\\\t\\\\t// get the number of pixels\\\\n\\\\t\\\\tvar totalPixels = frame.image.descriptor.width * frame.image.descriptor.height;\\\\n\\\\n\\\\t\\\\t// do lzw decompression\\\\n\\\\t\\\\tvar pixels = lzw(frame.image.data.minCodeSize, frame.image.data.blocks, totalPixels);\\\\n\\\\n\\\\t\\\\t// deal with interlacing if necessary\\\\n\\\\t\\\\tif(frame.image.descriptor.lct.interlaced){\\\\n\\\\t\\\\t\\\\tpixels = deinterlace(pixels, frame.image.descriptor.width);\\\\n\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t// setup usable image object\\\\n\\\\t\\\\tvar image = {\\\\n\\\\t\\\\t\\\\tpixels: pixels,\\\\n\\\\t\\\\t\\\\tdims: {\\\\n\\\\t\\\\t\\\\t\\\\ttop: frame.image.descriptor.top,\\\\n\\\\t\\\\t\\\\t\\\\tleft: frame.image.descriptor.left,\\\\n\\\\t\\\\t\\\\t\\\\twidth: frame.image.descriptor.width,\\\\n\\\\t\\\\t\\\\t\\\\theight: frame.image.descriptor.height\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t// color table\\\\n\\\\t\\\\tif(frame.image.descriptor.lct && frame.image.descriptor.lct.exists){\\\\n\\\\t\\\\t\\\\timage.colorTable = frame.image.lct;\\\\n\\\\t\\\\t}else{\\\\n\\\\t\\\\t\\\\timage.colorTable = this.raw.gct;\\\\n\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t// add per frame relevant gce information\\\\n\\\\t\\\\tif(frame.gce){\\\\n\\\\t\\\\t\\\\timage.delay = (frame.gce.delay || 10) * 10; // convert to ms\\\\n\\\\t\\\\t\\\\timage.disposalType = frame.gce.extras.disposal;\\\\n\\\\t\\\\t\\\\t// transparency\\\\n\\\\t\\\\t\\\\tif(frame.gce.extras.transparentColorGiven){\\\\n\\\\t\\\\t\\\\t\\\\timage.transparentIndex = frame.gce.transparentColorIndex;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t// create canvas usable imagedata if desired\\\\n\\\\t\\\\tif(buildPatch){\\\\n\\\\t\\\\t\\\\timage.patch = generatePatch(image);\\\\n\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\treturn image;\\\\n\\\\t}\\\\n\\\\n\\\\t// frame does not contains image\\\\n\\\\treturn null;\\\\n\\\\n\\\\n\\\\t/**\\\\n\\\\t * javascript port of java LZW decompression\\\\n\\\\t * Original java author url: https://gist.github.com/devunwired/4479231\\\\n\\\\t */\\\\n\\\\tfunction lzw(minCodeSize, data, pixelCount) {\\\\n\\\\n \\\\t\\\\tvar MAX_STACK_SIZE = 4096;\\\\n\\\\t\\\\tvar nullCode = -1;\\\\n\\\\n\\\\t\\\\tvar npix = pixelCount;\\\\n\\\\t\\\\tvar available, clear, code_mask, code_size, end_of_information, in_code, old_code, bits, code, i, datum, data_size, first, top, bi, pi;\\\\n\\\\n \\\\t\\\\tvar dstPixels = new Array(pixelCount);\\\\n\\\\t\\\\tvar prefix = new Array(MAX_STACK_SIZE);\\\\n\\\\t\\\\tvar suffix = new Array(MAX_STACK_SIZE);\\\\n\\\\t\\\\tvar pixelStack = new Array(MAX_STACK_SIZE + 1);\\\\n\\\\n\\\\t\\\\t// Initialize GIF data stream decoder.\\\\n\\\\t\\\\tdata_size = minCodeSize;\\\\n\\\\t\\\\tclear = 1 << data_size;\\\\n\\\\t\\\\tend_of_information = clear + 1;\\\\n\\\\t\\\\tavailable = clear + 2;\\\\n\\\\t\\\\told_code = nullCode;\\\\n\\\\t\\\\tcode_size = data_size + 1;\\\\n\\\\t\\\\tcode_mask = (1 << code_size) - 1;\\\\n\\\\t\\\\tfor (code = 0; code < clear; code++) {\\\\n\\\\t\\\\t\\\\tprefix[code] = 0;\\\\n\\\\t\\\\t\\\\tsuffix[code] = code;\\\\n\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t// Decode GIF pixel stream.\\\\n    let count;\\\\n\\\\t\\\\tdatum = bits = count = first = top = pi = bi = 0;\\\\n\\\\t\\\\tfor (i = 0; i < npix; ) {\\\\n\\\\t\\\\t\\\\tif (top === 0) {\\\\n\\\\t\\\\t\\\\t\\\\tif (bits < code_size) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t// get the next byte\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tdatum += data[bi] << bits;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tbits += 8;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tbi++;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tcontinue;\\\\n\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t// Get the next code.\\\\n\\\\t\\\\t\\\\t\\\\tcode = datum & code_mask;\\\\n\\\\t\\\\t\\\\t\\\\tdatum >>= code_size;\\\\n\\\\t\\\\t\\\\t\\\\tbits -= code_size;\\\\n\\\\t\\\\t\\\\t\\\\t// Interpret the code\\\\n\\\\t\\\\t\\\\t\\\\tif ((code > available) || (code == end_of_information)) {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tbreak;\\\\n\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\tif (code == clear) {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t// Reset decoder.\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tcode_size = data_size + 1;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tcode_mask = (1 << code_size) - 1;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tavailable = clear + 2;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\told_code = nullCode;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tcontinue;\\\\n\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\tif (old_code == nullCode) {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tpixelStack[top++] = suffix[code];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\told_code = code;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tfirst = code;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tcontinue;\\\\n\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\tin_code = code;\\\\n\\\\t\\\\t\\\\t\\\\tif (code == available) {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tpixelStack[top++] = first;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tcode = old_code;\\\\n\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\twhile (code > clear) {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tpixelStack[top++] = suffix[code];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tcode = prefix[code];\\\\n\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\tfirst = suffix[code] & 0xff;\\\\n\\\\t\\\\t\\\\t\\\\tpixelStack[top++] = first;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t// add a new string to the table, but only if space is available\\\\n\\\\t\\\\t\\\\t\\\\t// if not, just continue with current table until a clear code is found\\\\n\\\\t\\\\t\\\\t\\\\t// (deferred clear code implementation as per GIF spec)\\\\n\\\\t\\\\t\\\\t\\\\tif(available < MAX_STACK_SIZE){\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tprefix[available] = old_code;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tsuffix[available] = first;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tavailable++;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tif (((available & code_mask) === 0) && (available < MAX_STACK_SIZE)) {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcode_size++;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcode_mask += available;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\told_code = in_code;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t// Pop a pixel off the pixel stack.\\\\n\\\\t\\\\t\\\\ttop--;\\\\n\\\\t\\\\t\\\\tdstPixels[pi++] = pixelStack[top];\\\\n\\\\t\\\\t\\\\ti++;\\\\n\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\tfor (i = pi; i < npix; i++) {\\\\n\\\\t\\\\t\\\\tdstPixels[i] = 0; // clear missing pixels\\\\n\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\treturn dstPixels;\\\\n\\\\t}\\\\n\\\\n\\\\t// deinterlace function from https://github.com/shachaf/jsgif\\\\n\\\\tfunction deinterlace(pixels, width) {\\\\n\\\\n\\\\t\\\\tvar newPixels = new Array(pixels.length);\\\\n\\\\t\\\\tvar rows = pixels.length / width;\\\\n\\\\t\\\\tvar cpRow = function(toRow, fromRow) {\\\\n\\\\t\\\\t\\\\tvar fromPixels = pixels.slice(fromRow * width, (fromRow + 1) * width);\\\\n\\\\t\\\\t\\\\tnewPixels.splice.apply(newPixels, [toRow * width, width].concat(fromPixels));\\\\n\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t// See appendix E.\\\\n\\\\t\\\\tvar offsets = [0,4,2,1];\\\\n\\\\t\\\\tvar steps   = [8,8,4,2];\\\\n\\\\n\\\\t\\\\tvar fromRow = 0;\\\\n\\\\t\\\\tfor (var pass = 0; pass < 4; pass++) {\\\\n\\\\t\\\\t\\\\tfor (var toRow = offsets[pass]; toRow < rows; toRow += steps[pass]) {\\\\n\\\\t\\\\t\\\\t\\\\tcpRow(toRow, fromRow);\\\\n\\\\t\\\\t\\\\t\\\\tfromRow++;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\treturn newPixels;\\\\n\\\\t}\\\\n\\\\n\\\\t// create a clamped byte array patch for the frame image to be used directly with a canvas\\\\n\\\\t// TODO: could potentially squeeze some performance by doing a direct 32bit write per iteration\\\\n\\\\tfunction generatePatch(image){\\\\n\\\\n\\\\t\\\\tvar totalPixels = image.pixels.length;\\\\n\\\\t\\\\tvar patchData = new Uint8ClampedArray(totalPixels * 4);\\\\n\\\\t\\\\tfor(var i=0; i<totalPixels; i++){\\\\n\\\\t\\\\t\\\\tvar pos = i * 4;\\\\n\\\\t\\\\t\\\\tvar colorIndex = image.pixels[i];\\\\n\\\\t\\\\t\\\\tvar color = image.colorTable[colorIndex];\\\\n\\\\t\\\\t\\\\tpatchData[pos] = color[0];\\\\n\\\\t\\\\t\\\\tpatchData[pos + 1] = color[1];\\\\n\\\\t\\\\t\\\\tpatchData[pos + 2] = color[2];\\\\n\\\\t\\\\t\\\\tpatchData[pos + 3] = colorIndex !== image.transparentIndex ? 255 : 0;\\\\n\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\treturn patchData;\\\\n\\\\t}\\\\n};\\\\n\\\\n// returns all frames decompressed\\\\nGIF.prototype.decompressFrames = function(buildPatch){\\\\n\\\\tvar frames = [];\\\\n\\\\tfor(var i=0; i<this.raw.frames.length; i++){\\\\n\\\\t\\\\tvar frame = this.raw.frames[i];\\\\n\\\\t\\\\tif(frame.image){\\\\n\\\\t\\\\t\\\\tframes.push(this.decompressFrame(i, buildPatch));\\\\n\\\\t\\\\t}\\\\n\\\\t}\\\\n\\\\treturn frames;\\\\n};\\\\n\\\\nmodule.exports = GIF;\\\\n},{\\\\\\\"../bower_components/js-binary-schema-parser/src/dataparser\\\\\\\":2,\\\\\\\"./schema\\\\\\\":6}],6:[function(require,module,exports){\\\\n\\\\n// Schema for the js file parser to use to parse gif files\\\\n// For js object convenience (re-use), the schema objects are approximately reverse ordered\\\\n\\\\n// common parsers available\\\\nvar Parsers = require('../bower_components/js-binary-schema-parser/src/parsers');\\\\n\\\\n// a set of 0x00 terminated subblocks\\\\nvar subBlocks = {\\\\n\\\\tlabel: 'blocks',\\\\n\\\\tparser: function(stream){\\\\n\\\\t\\\\tvar out = [];\\\\n\\\\t\\\\tvar terminator = 0x00;\\\\n\\\\t\\\\tfor(var size=stream.readByte(); size!==terminator; size=stream.readByte()){\\\\n\\\\t\\\\t\\\\tout = out.concat(stream.readBytes(size));\\\\n\\\\t\\\\t}\\\\n\\\\t\\\\treturn out;\\\\n\\\\t}\\\\n};\\\\n\\\\n// global control extension\\\\nvar gce = {\\\\n\\\\tlabel: 'gce',\\\\n\\\\trequires: function(stream){\\\\n\\\\t\\\\t// just peek at the top two bytes, and if true do this\\\\n\\\\t\\\\tvar codes = stream.peekBytes(2);\\\\n\\\\t\\\\treturn codes[0] === 0x21 && codes[1] === 0xF9;\\\\n\\\\t},\\\\n\\\\tparts: [\\\\n\\\\t\\\\t{ label: 'codes', parser: Parsers.readBytes(2), skip: true },\\\\n\\\\t\\\\t{ label: 'byteSize', parser: Parsers.readByte() },\\\\n\\\\t\\\\t{ label: 'extras', bits: {\\\\n\\\\t\\\\t\\\\tfuture: { index: 0, length: 3 },\\\\n\\\\t\\\\t\\\\tdisposal: { index: 3, length: 3 },\\\\n\\\\t\\\\t\\\\tuserInput: { index: 6 },\\\\n\\\\t\\\\t\\\\ttransparentColorGiven: { index: 7 }\\\\n\\\\t\\\\t}},\\\\n\\\\t\\\\t{ label: 'delay', parser: Parsers.readUnsigned(true) },\\\\n\\\\t\\\\t{ label: 'transparentColorIndex', parser: Parsers.readByte() },\\\\n\\\\t\\\\t{ label: 'terminator', parser: Parsers.readByte(), skip: true }\\\\n\\\\t]\\\\n};\\\\n\\\\n// image pipeline block\\\\nvar image = {\\\\n\\\\tlabel: 'image',\\\\n\\\\trequires: function(stream){\\\\n\\\\t\\\\t// peek at the next byte\\\\n\\\\t\\\\tvar code = stream.peekByte();\\\\n\\\\t\\\\treturn code === 0x2C;\\\\n\\\\t},\\\\n\\\\tparts: [\\\\n\\\\t\\\\t{ label: 'code', parser: Parsers.readByte(), skip: true },\\\\n\\\\t\\\\t{\\\\n\\\\t\\\\t\\\\tlabel: 'descriptor', // image descriptor\\\\n\\\\t\\\\t\\\\tparts: [\\\\n\\\\t\\\\t\\\\t\\\\t{ label: 'left', parser: Parsers.readUnsigned(true) },\\\\n\\\\t\\\\t\\\\t\\\\t{ label: 'top', parser: Parsers.readUnsigned(true) },\\\\n\\\\t\\\\t\\\\t\\\\t{ label: 'width', parser: Parsers.readUnsigned(true) },\\\\n\\\\t\\\\t\\\\t\\\\t{ label: 'height', parser: Parsers.readUnsigned(true) },\\\\n\\\\t\\\\t\\\\t\\\\t{ label: 'lct', bits: {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\texists: { index: 0 },\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tinterlaced: { index: 1 },\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tsort: { index: 2 },\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tfuture: { index: 3, length: 2 },\\\\n\\\\t\\\\t\\\\t\\\\t\\\\tsize: { index: 5, length: 3 }\\\\n\\\\t\\\\t\\\\t\\\\t}}\\\\n\\\\t\\\\t\\\\t]\\\\n\\\\t\\\\t},{\\\\n\\\\t\\\\t\\\\tlabel: 'lct', // optional local color table\\\\n\\\\t\\\\t\\\\trequires: function(stream, obj, parent){\\\\n\\\\t\\\\t\\\\t\\\\treturn parent.descriptor.lct.exists;\\\\n\\\\t\\\\t\\\\t},\\\\n\\\\t\\\\t\\\\tparser: Parsers.readArray(3, function(stream, obj, parent){\\\\n\\\\t\\\\t\\\\t\\\\treturn Math.pow(2, parent.descriptor.lct.size + 1);\\\\n\\\\t\\\\t\\\\t})\\\\n\\\\t\\\\t},{\\\\n\\\\t\\\\t\\\\tlabel: 'data', // the image data blocks\\\\n\\\\t\\\\t\\\\tparts: [\\\\n\\\\t\\\\t\\\\t\\\\t{ label: 'minCodeSize', parser: Parsers.readByte() },\\\\n\\\\t\\\\t\\\\t\\\\tsubBlocks\\\\n\\\\t\\\\t\\\\t]\\\\n\\\\t\\\\t}\\\\n\\\\t]\\\\n};\\\\n\\\\n// plain text block\\\\nvar text = {\\\\n\\\\tlabel: 'text',\\\\n\\\\trequires: function(stream){\\\\n\\\\t\\\\t// just peek at the top two bytes, and if true do this\\\\n\\\\t\\\\tvar codes = stream.peekBytes(2);\\\\n\\\\t\\\\treturn codes[0] === 0x21 && codes[1] === 0x01;\\\\n\\\\t},\\\\n\\\\tparts: [\\\\n\\\\t\\\\t{ label: 'codes', parser: Parsers.readBytes(2), skip: true },\\\\n\\\\t\\\\t{ label: 'blockSize', parser: Parsers.readByte() },\\\\n\\\\t\\\\t{\\\\n\\\\t\\\\t\\\\tlabel: 'preData',\\\\n\\\\t\\\\t\\\\tparser: function(stream, obj, parent){\\\\n\\\\t\\\\t\\\\t\\\\treturn stream.readBytes(parent.text.blockSize);\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t},\\\\n\\\\t\\\\tsubBlocks\\\\n\\\\t]\\\\n};\\\\n\\\\n// application block\\\\nvar application = {\\\\n\\\\tlabel: 'application',\\\\n\\\\trequires: function(stream, obj, parent){\\\\n\\\\t\\\\t// make sure this frame doesn't already have a gce, text, comment, or image\\\\n\\\\t\\\\t// as that means this block should be attached to the next frame\\\\n\\\\t\\\\t//if(parent.gce || parent.text || parent.image || parent.comment){ return false; }\\\\n\\\\n\\\\t\\\\t// peek at the top two bytes\\\\n\\\\t\\\\tvar codes = stream.peekBytes(2);\\\\n\\\\t\\\\treturn codes[0] === 0x21 && codes[1] === 0xFF;\\\\n\\\\t},\\\\n\\\\tparts: [\\\\n\\\\t\\\\t{ label: 'codes', parser: Parsers.readBytes(2), skip: true },\\\\n\\\\t\\\\t{ label: 'blockSize', parser: Parsers.readByte() },\\\\n\\\\t\\\\t{\\\\n\\\\t\\\\t\\\\tlabel: 'id',\\\\n\\\\t\\\\t\\\\tparser: function(stream, obj, parent){\\\\n\\\\t\\\\t\\\\t\\\\treturn stream.readString(parent.blockSize);\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t},\\\\n\\\\t\\\\tsubBlocks\\\\n\\\\t]\\\\n};\\\\n\\\\n// comment block\\\\nvar comment = {\\\\n\\\\tlabel: 'comment',\\\\n\\\\trequires: function(stream, obj, parent){\\\\n\\\\t\\\\t// make sure this frame doesn't already have a gce, text, comment, or image\\\\n\\\\t\\\\t// as that means this block should be attached to the next frame\\\\n\\\\t\\\\t//if(parent.gce || parent.text || parent.image || parent.comment){ return false; }\\\\n\\\\n\\\\t\\\\t// peek at the top two bytes\\\\n\\\\t\\\\tvar codes = stream.peekBytes(2);\\\\n\\\\t\\\\treturn codes[0] === 0x21 && codes[1] === 0xFE;\\\\n\\\\t},\\\\n\\\\tparts: [\\\\n\\\\t\\\\t{ label: 'codes', parser: Parsers.readBytes(2), skip: true },\\\\n\\\\t\\\\tsubBlocks\\\\n\\\\t]\\\\n};\\\\n\\\\n// frames of ext and image data\\\\nvar frames = {\\\\n\\\\tlabel: 'frames',\\\\n\\\\tparts: [\\\\n\\\\t\\\\tgce,\\\\n\\\\t\\\\tapplication,\\\\n\\\\t\\\\tcomment,\\\\n\\\\t\\\\timage,\\\\n\\\\t\\\\ttext\\\\n\\\\t],\\\\n\\\\tloop: function(stream){\\\\n\\\\t\\\\tvar nextCode = stream.peekByte();\\\\n\\\\t\\\\t// rather than check for a terminator, we should check for the existence\\\\n\\\\t\\\\t// of an ext or image block to avoid infinite loops\\\\n\\\\t\\\\t//var terminator = 0x3B;\\\\n\\\\t\\\\t//return nextCode !== terminator;\\\\n\\\\t\\\\treturn nextCode === 0x21 || nextCode === 0x2C;\\\\n\\\\t}\\\\n};\\\\n\\\\n// main GIF schema\\\\nvar schemaGIF = [\\\\n\\\\t{\\\\n\\\\t\\\\tlabel: 'header', // gif header\\\\n\\\\t\\\\tparts: [\\\\n\\\\t\\\\t\\\\t{ label: 'signature', parser: Parsers.readString(3) },\\\\n\\\\t\\\\t\\\\t{ label: 'version', parser: Parsers.readString(3) }\\\\n\\\\t\\\\t]\\\\n\\\\t},{\\\\n\\\\t\\\\tlabel: 'lsd', // local screen descriptor\\\\n\\\\t\\\\tparts: [\\\\n\\\\t\\\\t\\\\t{ label: 'width', parser: Parsers.readUnsigned(true) },\\\\n\\\\t\\\\t\\\\t{ label: 'height', parser: Parsers.readUnsigned(true) },\\\\n\\\\t\\\\t\\\\t{ label: 'gct', bits: {\\\\n\\\\t\\\\t\\\\t\\\\texists: { index: 0 },\\\\n\\\\t\\\\t\\\\t\\\\tresolution: { index: 1, length: 3 },\\\\n\\\\t\\\\t\\\\t\\\\tsort: { index: 4 },\\\\n\\\\t\\\\t\\\\t\\\\tsize: { index: 5, length: 3 }\\\\n\\\\t\\\\t\\\\t}},\\\\n\\\\t\\\\t\\\\t{ label: 'backgroundColorIndex', parser: Parsers.readByte() },\\\\n\\\\t\\\\t\\\\t{ label: 'pixelAspectRatio', parser: Parsers.readByte() }\\\\n\\\\t\\\\t]\\\\n\\\\t},{\\\\n\\\\t\\\\tlabel: 'gct', // global color table\\\\n\\\\t\\\\trequires: function(stream, obj){\\\\n\\\\t\\\\t\\\\treturn obj.lsd.gct.exists;\\\\n\\\\t\\\\t},\\\\n\\\\t\\\\tparser: Parsers.readArray(3, function(stream, obj){\\\\n\\\\t\\\\t\\\\treturn Math.pow(2, obj.lsd.gct.size + 1);\\\\n\\\\t\\\\t})\\\\n\\\\t},\\\\n\\\\tframes // content frames\\\\n];\\\\n\\\\nmodule.exports = schemaGIF;\\\\n},{\\\\\\\"../bower_components/js-binary-schema-parser/src/parsers\\\\\\\":3}]},{},[4])\\\\n\\\\n\\\\n//# sourceURL=webpack://Raycaster/./src/external/gifuct-js.min.js?\\\");\\n\\n/***/ }),\\n\\n/***/ \\\"./src/texture.worker.js\\\":\\n/*!*******************************!*\\\\\\n  !*** ./src/texture.worker.js ***!\\n  \\\\*******************************/\\n/*! no exports provided */\\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\neval(\\\"__webpack_require__.r(__webpack_exports__);\\\\n/* harmony import */ var _external_gifuct_js_min_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./external/gifuct-js.min.js */ \\\\\\\"./src/external/gifuct-js.min.js\\\\\\\");\\\\n// Somehow works\\\\r\\\\n\\\\r\\\\n\\\\r\\\\nconst GIF = _external_gifuct_js_min_js__WEBPACK_IMPORTED_MODULE_0__[\\\\\\\"window\\\\\\\"].GIF;\\\\r\\\\n\\\\r\\\\nasync function GIFFrame(frame) {\\\\r\\\\n  let imageData = new ImageData(frame.patch, frame.dims.width, frame.dims.height);\\\\r\\\\n  let imageBitmap = await createImageBitmap(imageData, 0, 0, frame.dims.width, frame.dims.height);\\\\r\\\\n  return {\\\\r\\\\n    bmp: imageBitmap,\\\\r\\\\n    frameLength: frame.delay\\\\r\\\\n  };\\\\r\\\\n}\\\\r\\\\n\\\\r\\\\nself.addEventListener('message', function(e) {\\\\r\\\\n  let msg = e.data;\\\\r\\\\n  if (msg.type === 'loadGIF') {\\\\r\\\\n    let url = msg.url;\\\\r\\\\n    let options = msg.options;\\\\r\\\\n    fetch(url, {\\\\r\\\\n      method: 'GET'\\\\r\\\\n    })\\\\r\\\\n    .then((resp) => {\\\\r\\\\n      if (!resp.ok) {\\\\r\\\\n        throw new Error('Fetch failed at \\\\\\\"' + url + '\\\\\\\" ' + resp.statusText + \\\\\\\" (\\\\\\\" + resp.status + \\\\\\\")\\\\\\\");\\\\r\\\\n      }\\\\r\\\\n      else {\\\\r\\\\n        return resp.arrayBuffer();\\\\r\\\\n      }\\\\r\\\\n    })\\\\r\\\\n    .then((data) => new GIF(data))\\\\r\\\\n    .then((gif) => {\\\\r\\\\n      let frames = gif.decompressFrames(true);\\\\r\\\\n      if ('alpha' in options && !options.alpha) {\\\\r\\\\n        frames.forEach((f) => {\\\\r\\\\n          if (f.disposalType === 1) {\\\\r\\\\n            for (let i = 0; i < f.patch.length; i++) {\\\\r\\\\n              if (f.patch[i] === 0) {\\\\r\\\\n                f.patch[i] = 0;\\\\r\\\\n              }\\\\r\\\\n            }\\\\r\\\\n          }\\\\r\\\\n        });\\\\r\\\\n      }\\\\r\\\\n      frames.forEach((frame) => {\\\\r\\\\n        // delete frame.pixels;\\\\r\\\\n      });\\\\r\\\\n      let promisedFrames = frames.map((f) => GIFFrame(f));\\\\r\\\\n      Promise.all(promisedFrames).then((loadedFrames) => {\\\\r\\\\n        // console.log('finished',data);\\\\r\\\\n        self.postMessage({\\\\r\\\\n          type: 'loadGIF',\\\\r\\\\n          loadedFrames: loadedFrames\\\\r\\\\n        });\\\\r\\\\n      });\\\\r\\\\n    });\\\\r\\\\n  }\\\\r\\\\n  if (msg.type === 'loadGIFFrames') {\\\\r\\\\n\\\\r\\\\n  }\\\\r\\\\n});\\\\r\\\\n\\\\n\\\\n//# sourceURL=webpack://Raycaster/./src/texture.worker.js?\\\");\\n\\n/***/ })\\n\\n/******/ });\", __webpack_require__.p + \"texture.worker.js\");\n};\n\n//# sourceURL=webpack://Raycaster/./src/texture.worker.js?");

/***/ }),

/***/ "./src/util.js":
/*!*********************!*\
  !*** ./src/util.js ***!
  \*********************/
/*! exports provided: requestPointerLock, scale, MapBuilder, Minimap, intersect */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"requestPointerLock\", function() { return requestPointerLock; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scale\", function() { return scale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MapBuilder\", function() { return MapBuilder; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Minimap\", function() { return Minimap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"intersect\", function() { return intersect; });\n/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color */ \"./src/color.js\");\n\n\nfunction requestPointerLock(game) {\n  game.input.mouse.requestPointerLock();\n}\n\nfunction scale(num, inMin, inMax, outMin, outMax) {\n  return (num - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;\n}\n\n/*\n  Data map is in the format:\n[\n  [\n    [2, 1, 0],\n    [1, 1, 0],\n    [1, 0, 2]\n  ],\n  {\n    0: {\n      object: Wall,\n      arguments: [{height:2}]\n    },\n    1: {\n      object: Wall,\n      arguments: [{texture:'foo'}]\n    },\n    2: {\n      object: CustomWall,\n      arguments: []\n    },\n  }\n]\nNOTE: Values in first array may also be arrays in the format of [value, arguments] to override the predefined arguments for said value.\nNOTE: This format also inherently supports other data types such as strings instead of numbers to serve as instances. This may be more clear if desired.\nNOTE: Arguments passed to each class reference will go:\n  \"(raycaster instance, x1, y1, x2, y2, ...args)\"\n  If the class instance's constructor doesn't comply with this format, you may instead pass in a helper function to construct the instance:\n  // NOTE: This format also be helpful in the instantiation of new arguments every time (instead of reusing the same preinstantiated object)\n    [\n      0: {\n        helper: function(raycaster, x1, y1, x2, y2) {\n          return new CustomWall(raycaster, x1, y1, x2, y2, {texture:'bar'})\n        }\n      }\n    ]\n*/\nconst MapBuilder = {\n  build(raycaster, dataMap, xDimensions, yDimensions) {\n    const map = [];\n    const height = raycaster.worldHeight / Math.max(yDimensions, dataMap[0].length);\n    for (let yInd = 0; yInd < dataMap[0].length; yInd++) {\n      const width = raycaster.worldWidth / Math.max(xDimensions, dataMap[0][yInd].length);\n      for (let xInd = 0; xInd < dataMap[0][yInd].length; xInd++) {\n        let type = dataMap[0][yInd][xInd];\n        let object;\n        const x1 = width * xInd;\n        const x2 = x1 + width;\n        const y1 = height * yInd;\n        const y2 = y1 + height;\n\n\n        let args;\n\n        if (typeof type === \"undefined\" || type === null || type === undefined) {\n          continue;\n        }\n\n        if (Array.isArray(type)) {\n          [type, ...args] = type;\n        }\n\n        const data = dataMap[1][type];\n\n        if (typeof data === \"undefined\" || data === null || data === undefined) {\n          continue;\n        }\n\n        if (typeof args === 'undefined') args = Object.prototype.hasOwnProperty.call(data, 'arguments') ? data.arguments : [];\n\n        if (Object.prototype.hasOwnProperty.call(data, 'helper')) {\n          object = data.helper(raycaster, x1, y1, x2, y2);\n        } else {\n          // eslint-disable-next-line new-cap\n          object = new data.object(raycaster, x1, y1, x2, y2, ...args);\n        }\n        map.push(object);\n        // super(raycaster,x,y,x2,y2,height,options);\n      }\n    }\n    return map;\n  },\n  loadFromFile(file) {\n    // TODO\n\n  },\n};\n\n/**\n * Minimap utility class\n *\n * @param {PlanarObject} object - The object that the minimap is rendered relative to. May be reassigned at any point.\n * @param {number} x - X-axis coordinate in which the minimap will be rendered onto the screen;\n * @param {number} y - Y-axis coordinate in which the minimap will be rendered onto the screen;\n * @param {number} width - The width of the minimap in pixels.\n * @param {number} height - The height of the minimap in pixels.\n * @param {number|null} [viewWidth=null] - The amount of in-game width rendered on the minimap. Default shows the entire map.\n * @param {number|null} [viewHeight=null] - The amount of in-game height rendered on the minimap. Default shows the entire map.\n * @param {object} [options={}] - Additional options.\n * @param {Color} [options.backgroundColor=new Color(80,80,80,1)] - Background color of the Minimap.\n * @param {Color} [options.borderColor=new Color(50,50,50,1)] - Border color of the Minimap.\n * @param {number} [options.borderWidth=0] - Width of the Minimap's border.\n *\n */\nclass Minimap {\n  constructor(object, x, y, width, height, viewWidth=null, viewHeight=null, options={}) {\n    this.object = object;\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.viewWidth = viewWidth;\n    this.viewHeight = viewHeight;\n\n    this.options = {\n      backgroundColor:new _color__WEBPACK_IMPORTED_MODULE_0__[\"default\"](80,80,80,1),\n      borderColor:new _color__WEBPACK_IMPORTED_MODULE_0__[\"default\"](50,50,50,1),\n      borderWidth:0\n    };\n    Object.keys(options).forEach((key) => {\n      if (Object.prototype.hasOwnProperty.call(this.options, key)) {\n        this.options[key] = options[key];\n      }\n    });\n    Object.keys(this.options).forEach((key) => {\n      this[key] = this.options[key];\n    });\n    delete this.options;\n  }\n  /**\n   * Method for rendering the minimap onto the screen\n   */\n  render() {\n    let ctx = this.object.game.canvas.getContext('2d');\n    let gameWidth = this.object.raycaster.worldWidth;\n    let gameHeight = this.object.raycaster.worldHeight;\n    if (this.borderWidth !== 0) {\n      ctx.fillStyle = this.borderColor.toCSSString();\n      ctx.fillRect(this.x-this.borderWidth,this.y-this.borderWidth,this.width+(this.borderWidth*2),this.height+(this.borderWidth*2));\n    }\n    ctx.fillStyle = this.backgroundColor.toCSSString();\n    ctx.fillRect(this.x, this.y, this.width, this.height);\n    this.object.raycaster.objects.forEach((obj,i) => {\n      let color = obj.color.toCSSString();\n      let startX = this.x + this.width * (obj.start.x / gameWidth);\n      let startY = this.y + this.height * (obj.start.y / gameHeight);\n      let endX = this.x + this.width * (obj.end.x / gameWidth);\n      let endY = this.y + this.height * (obj.end.y / gameHeight);\n      ctx.strokeStyle = color;\n      ctx.moveTo(startX,startY);\n      ctx.lineTo(endX,endY);\n    });\n    ctx.stroke();\n  }\n}\n\nfunction intersect(x1, y1, x2, y2, x3, y3, x4, y4) {\n  // Check if none of the lines are of length 0\n  if ((x1 === x2 && y1 === y2) || (x3 === x4 && y3 === y4)) {\n    return false;\n  }\n\n  const denominator = ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));\n\n  // Lines are parallel\n  if (denominator === 0) {\n    return false;\n  }\n\n  const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator;\n  const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator;\n\n  // is the intersection along the segments\n  if (ua < 0 || ua > 1 || ub < 0 || ub > 1) {\n    return false;\n  }\n\n  // Return a object with the x and y coordinates of the intersection\n  const x = x1 + ua * (x2 - x1);\n  const y = y1 + ua * (y2 - y1);\n\n  return { x, y };\n}\n\n\n//# sourceURL=webpack://Raycaster/./src/util.js?");

/***/ })

/******/ });