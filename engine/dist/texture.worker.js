/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/texture.worker.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/external/gifuct-js.min.js":
/*!***************************************!*\
  !*** ./src/external/gifuct-js.min.js ***!
  \***************************************/
/*! exports provided: window */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"window\", function() { return window; });\nvar require;var require;const window = {};\n(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n\n// Stream object for reading off bytes from a byte array\n\nfunction ByteStream(data){\n\tthis.data = data;\n\tthis.pos = 0;\n}\n\n// read the next byte off the stream\nByteStream.prototype.readByte = function(){\n\treturn this.data[this.pos++];\n};\n\n// look at the next byte in the stream without updating the stream position\nByteStream.prototype.peekByte = function(){\n\treturn this.data[this.pos];\n};\n\n// read an array of bytes\nByteStream.prototype.readBytes = function(n){\n\tvar bytes = new Array(n);\n\tfor(var i=0; i<n; i++){\n\t\tbytes[i] = this.readByte();\n\t}\n\treturn bytes;\n};\n\n// peek at an array of bytes without updating the stream position\nByteStream.prototype.peekBytes = function(n){\n\tvar bytes = new Array(n);\n\tfor(var i=0; i<n; i++){\n\t\tbytes[i] = this.data[this.pos + i];\n\t}\n\treturn bytes;\n};\n\n// read a string from a byte set\nByteStream.prototype.readString = function(len){\n\tvar str = '';\n\tfor(var i=0; i<len; i++){\n\t\tstr += String.fromCharCode(this.readByte());\n\t}\n\treturn str;\n};\n\n// read a single byte and return an array of bit booleans\nByteStream.prototype.readBitArray = function(){\n\tvar arr = [];\n\tvar bite = this.readByte();\n\tfor (var i = 7; i >= 0; i--) {\n\t\tarr.push(!!(bite & (1 << i)));\n\t}\n\treturn arr;\n};\n\n// read an unsigned int with endian option\nByteStream.prototype.readUnsigned = function(littleEndian){\n\tvar a = this.readBytes(2);\n\tif(littleEndian){\n\t\treturn (a[1] << 8) + a[0];\n\t}else{\n\t\treturn (a[0] << 8) + a[1];\n\t}\n};\n\nmodule.exports = ByteStream;\n},{}],2:[function(require,module,exports){\n\n// Primary data parsing object used to parse byte arrays\n\nvar ByteStream = require('./bytestream');\n\nfunction DataParser(data){\n\tthis.stream = new ByteStream(data);\n\t// the final parsed object from the data\n\tthis.output = {};\n}\n\nDataParser.prototype.parse = function(schema){\n\t// the top level schema is just the top level parts array\n\tthis.parseParts(this.output, schema);\n\treturn this.output;\n};\n\n// parse a set of hierarchy parts providing the parent object, and the subschema\nDataParser.prototype.parseParts = function(obj, schema){\n\tfor(var i=0; i<schema.length; i++){\n\t\tvar part = schema[i];\n\t\tthis.parsePart(obj, part);\n\t}\n};\n\nDataParser.prototype.parsePart = function(obj, part){\n\tvar name = part.label;\n\tvar value;\n\n\t// make sure the part meets any parse requirements\n\tif(part.requires && ! part.requires(this.stream, this.output, obj)){\n\t\treturn;\n\t}\n\n\tif(part.loop){\n\t\t// create a parse loop over the parts\n\t\tvar items = [];\n\t\twhile(part.loop(this.stream)){\n\t\t\tvar item = {};\n\t\t\tthis.parseParts(item, part.parts);\n\t\t\titems.push(item);\n\t\t}\n\t\tobj[name] = items;\n\t}else if(part.parts){\n\t\t// process any child parts\n\t\tvalue = {};\n\t\tthis.parseParts(value, part.parts);\n\t\tobj[name] = value;\n\t}else if(part.parser){\n\t\t// parse the value using a parser\n\t\tvalue = part.parser(this.stream, this.output, obj);\n\t\tif(!part.skip){\n\t\t\tobj[name] = value;\n\t\t}\n\t}else if(part.bits){\n\t\t// convert the next byte to a set of bit fields\n\t\tobj[name] = this.parseBits(part.bits);\n\t}\n};\n\n// combine bits to calculate value\nfunction bitsToNum(bitArray){\n\treturn bitArray.reduce(function(s, n) { return s * 2 + n; }, 0);\n}\n\n// parse a byte as a bit set (flags and values)\nDataParser.prototype.parseBits = function(details){\n\tvar out = {};\n\tvar bits = this.stream.readBitArray();\n\tfor(var key in details){\n\t\tvar item = details[key];\n\t\tif(item.length){\n\t\t\t// convert the bit set to value\n\t\t\tout[key] = bitsToNum(bits.slice(item.index, item.index + item.length));\n\t\t}else{\n\t\t\tout[key] = bits[item.index];\n\t\t}\n\t}\n\treturn out;\n};\n\nmodule.exports = DataParser;\n},{\"./bytestream\":1}],3:[function(require,module,exports){\n\n// a set of common parsers used with DataParser\n\nvar Parsers = {\n\t// read a byte\n\treadByte: function(){\n\t\treturn function(stream){\n\t\t\treturn stream.readByte();\n\t\t};\n\t},\n\t// read an array of bytes\n\treadBytes: function(length){\n\t\treturn function(stream){\n\t\t\treturn stream.readBytes(length);\n\t\t};\n\t},\n\t// read a string from bytes\n\treadString: function(length){\n\t\treturn function(stream){\n\t\t\treturn stream.readString(length);\n\t\t};\n\t},\n\t// read an unsigned int (with endian)\n\treadUnsigned: function(littleEndian){\n\t\treturn function(stream){\n\t\t\treturn stream.readUnsigned(littleEndian);\n\t\t};\n\t},\n\t// read an array of byte sets\n\treadArray: function(size, countFunc){\n\t\treturn function(stream, obj, parent){\n\t\t\tvar count = countFunc(stream, obj, parent);\n\t\t\tvar arr = new Array(count);\n\t\t\tfor(var i=0; i<count; i++){\n\t\t\t\tarr[i] = stream.readBytes(size);\n\t\t\t}\n\t\t\treturn arr;\n\t\t};\n\t}\n};\n\nmodule.exports = Parsers;\n},{}],4:[function(require,module,exports){\n// export wrapper for exposing library\n\nvar GIF = window.GIF || {};\n\nGIF = require('./gif');\n\nwindow.GIF = GIF;\n},{\"./gif\":5}],5:[function(require,module,exports){\n\n// object used to represent array buffer data for a gif file\n\nvar DataParser = require('../bower_components/js-binary-schema-parser/src/dataparser');\nvar gifSchema = require('./schema');\n\nfunction GIF(arrayBuffer){\n\t// convert to byte array\n\tvar byteData = new Uint8Array(arrayBuffer);\n\tvar parser = new DataParser(byteData);\n\t// parse the data\n\tthis.raw = parser.parse(gifSchema);\n\n\t// set a flag to make sure the gif contains at least one image\n\tthis.raw.hasImages = false;\n\tfor(var f=0; f<this.raw.frames.length; f++){\n\t\tif(this.raw.frames[f].image){\n\t\t\tthis.raw.hasImages = true;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n// process a single gif image frames data, decompressing it using LZW\n// if buildPatch is true, the returned image will be a clamped 8 bit image patch\n// for use directly with a canvas.\nGIF.prototype.decompressFrame = function(index, buildPatch){\n\n\t// make sure a valid frame is requested\n\tif(index >= this.raw.frames.length){ return null; }\n\n\tvar frame = this.raw.frames[index];\n\tif(frame.image){\n\t\t// get the number of pixels\n\t\tvar totalPixels = frame.image.descriptor.width * frame.image.descriptor.height;\n\n\t\t// do lzw decompression\n\t\tvar pixels = lzw(frame.image.data.minCodeSize, frame.image.data.blocks, totalPixels);\n\n\t\t// deal with interlacing if necessary\n\t\tif(frame.image.descriptor.lct.interlaced){\n\t\t\tpixels = deinterlace(pixels, frame.image.descriptor.width);\n\t\t}\n\n\t\t// setup usable image object\n\t\tvar image = {\n\t\t\tpixels: pixels,\n\t\t\tdims: {\n\t\t\t\ttop: frame.image.descriptor.top,\n\t\t\t\tleft: frame.image.descriptor.left,\n\t\t\t\twidth: frame.image.descriptor.width,\n\t\t\t\theight: frame.image.descriptor.height\n\t\t\t}\n\t\t};\n\n\t\t// color table\n\t\tif(frame.image.descriptor.lct && frame.image.descriptor.lct.exists){\n\t\t\timage.colorTable = frame.image.lct;\n\t\t}else{\n\t\t\timage.colorTable = this.raw.gct;\n\t\t}\n\n\t\t// add per frame relevant gce information\n\t\tif(frame.gce){\n\t\t\timage.delay = (frame.gce.delay || 10) * 10; // convert to ms\n\t\t\timage.disposalType = frame.gce.extras.disposal;\n\t\t\t// transparency\n\t\t\tif(frame.gce.extras.transparentColorGiven){\n\t\t\t\timage.transparentIndex = frame.gce.transparentColorIndex;\n\t\t\t}\n\t\t}\n\n\t\t// create canvas usable imagedata if desired\n\t\tif(buildPatch){\n\t\t\timage.patch = generatePatch(image);\n\t\t}\n\n\t\treturn image;\n\t}\n\n\t// frame does not contains image\n\treturn null;\n\n\n\t/**\n\t * javascript port of java LZW decompression\n\t * Original java author url: https://gist.github.com/devunwired/4479231\n\t */\n\tfunction lzw(minCodeSize, data, pixelCount) {\n\n \t\tvar MAX_STACK_SIZE = 4096;\n\t\tvar nullCode = -1;\n\n\t\tvar npix = pixelCount;\n\t\tvar available, clear, code_mask, code_size, end_of_information, in_code, old_code, bits, code, i, datum, data_size, first, top, bi, pi;\n\n \t\tvar dstPixels = new Array(pixelCount);\n\t\tvar prefix = new Array(MAX_STACK_SIZE);\n\t\tvar suffix = new Array(MAX_STACK_SIZE);\n\t\tvar pixelStack = new Array(MAX_STACK_SIZE + 1);\n\n\t\t// Initialize GIF data stream decoder.\n\t\tdata_size = minCodeSize;\n\t\tclear = 1 << data_size;\n\t\tend_of_information = clear + 1;\n\t\tavailable = clear + 2;\n\t\told_code = nullCode;\n\t\tcode_size = data_size + 1;\n\t\tcode_mask = (1 << code_size) - 1;\n\t\tfor (code = 0; code < clear; code++) {\n\t\t\tprefix[code] = 0;\n\t\t\tsuffix[code] = code;\n\t\t}\n\n\t\t// Decode GIF pixel stream.\n    let count;\n\t\tdatum = bits = count = first = top = pi = bi = 0;\n\t\tfor (i = 0; i < npix; ) {\n\t\t\tif (top === 0) {\n\t\t\t\tif (bits < code_size) {\n\n\t\t\t\t\t// get the next byte\n\t\t\t\t\tdatum += data[bi] << bits;\n\n\t\t\t\t\tbits += 8;\n\t\t\t\t\tbi++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// Get the next code.\n\t\t\t\tcode = datum & code_mask;\n\t\t\t\tdatum >>= code_size;\n\t\t\t\tbits -= code_size;\n\t\t\t\t// Interpret the code\n\t\t\t\tif ((code > available) || (code == end_of_information)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (code == clear) {\n\t\t\t\t\t// Reset decoder.\n\t\t\t\t\tcode_size = data_size + 1;\n\t\t\t\t\tcode_mask = (1 << code_size) - 1;\n\t\t\t\t\tavailable = clear + 2;\n\t\t\t\t\told_code = nullCode;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (old_code == nullCode) {\n\t\t\t\t\tpixelStack[top++] = suffix[code];\n\t\t\t\t\told_code = code;\n\t\t\t\t\tfirst = code;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tin_code = code;\n\t\t\t\tif (code == available) {\n\t\t\t\t\tpixelStack[top++] = first;\n\t\t\t\t\tcode = old_code;\n\t\t\t\t}\n\t\t\t\twhile (code > clear) {\n\t\t\t\t\tpixelStack[top++] = suffix[code];\n\t\t\t\t\tcode = prefix[code];\n\t\t\t\t}\n\n\t\t\t\tfirst = suffix[code] & 0xff;\n\t\t\t\tpixelStack[top++] = first;\n\n\t\t\t\t// add a new string to the table, but only if space is available\n\t\t\t\t// if not, just continue with current table until a clear code is found\n\t\t\t\t// (deferred clear code implementation as per GIF spec)\n\t\t\t\tif(available < MAX_STACK_SIZE){\n\t\t\t\t\tprefix[available] = old_code;\n\t\t\t\t\tsuffix[available] = first;\n\t\t\t\t\tavailable++;\n\t\t\t\t\tif (((available & code_mask) === 0) && (available < MAX_STACK_SIZE)) {\n\t\t\t\t\t\tcode_size++;\n\t\t\t\t\t\tcode_mask += available;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\told_code = in_code;\n\t\t\t}\n\t\t\t// Pop a pixel off the pixel stack.\n\t\t\ttop--;\n\t\t\tdstPixels[pi++] = pixelStack[top];\n\t\t\ti++;\n\t\t}\n\n\t\tfor (i = pi; i < npix; i++) {\n\t\t\tdstPixels[i] = 0; // clear missing pixels\n\t\t}\n\n\t\treturn dstPixels;\n\t}\n\n\t// deinterlace function from https://github.com/shachaf/jsgif\n\tfunction deinterlace(pixels, width) {\n\n\t\tvar newPixels = new Array(pixels.length);\n\t\tvar rows = pixels.length / width;\n\t\tvar cpRow = function(toRow, fromRow) {\n\t\t\tvar fromPixels = pixels.slice(fromRow * width, (fromRow + 1) * width);\n\t\t\tnewPixels.splice.apply(newPixels, [toRow * width, width].concat(fromPixels));\n\t\t};\n\n\t\t// See appendix E.\n\t\tvar offsets = [0,4,2,1];\n\t\tvar steps   = [8,8,4,2];\n\n\t\tvar fromRow = 0;\n\t\tfor (var pass = 0; pass < 4; pass++) {\n\t\t\tfor (var toRow = offsets[pass]; toRow < rows; toRow += steps[pass]) {\n\t\t\t\tcpRow(toRow, fromRow);\n\t\t\t\tfromRow++;\n\t\t\t}\n\t\t}\n\n\t\treturn newPixels;\n\t}\n\n\t// create a clamped byte array patch for the frame image to be used directly with a canvas\n\t// TODO: could potentially squeeze some performance by doing a direct 32bit write per iteration\n\tfunction generatePatch(image){\n\n\t\tvar totalPixels = image.pixels.length;\n\t\tvar patchData = new Uint8ClampedArray(totalPixels * 4);\n\t\tfor(var i=0; i<totalPixels; i++){\n\t\t\tvar pos = i * 4;\n\t\t\tvar colorIndex = image.pixels[i];\n\t\t\tvar color = image.colorTable[colorIndex];\n\t\t\tpatchData[pos] = color[0];\n\t\t\tpatchData[pos + 1] = color[1];\n\t\t\tpatchData[pos + 2] = color[2];\n\t\t\tpatchData[pos + 3] = colorIndex !== image.transparentIndex ? 255 : 0;\n\t\t}\n\n\t\treturn patchData;\n\t}\n};\n\n// returns all frames decompressed\nGIF.prototype.decompressFrames = function(buildPatch){\n\tvar frames = [];\n\tfor(var i=0; i<this.raw.frames.length; i++){\n\t\tvar frame = this.raw.frames[i];\n\t\tif(frame.image){\n\t\t\tframes.push(this.decompressFrame(i, buildPatch));\n\t\t}\n\t}\n\treturn frames;\n};\n\nmodule.exports = GIF;\n},{\"../bower_components/js-binary-schema-parser/src/dataparser\":2,\"./schema\":6}],6:[function(require,module,exports){\n\n// Schema for the js file parser to use to parse gif files\n// For js object convenience (re-use), the schema objects are approximately reverse ordered\n\n// common parsers available\nvar Parsers = require('../bower_components/js-binary-schema-parser/src/parsers');\n\n// a set of 0x00 terminated subblocks\nvar subBlocks = {\n\tlabel: 'blocks',\n\tparser: function(stream){\n\t\tvar out = [];\n\t\tvar terminator = 0x00;\n\t\tfor(var size=stream.readByte(); size!==terminator; size=stream.readByte()){\n\t\t\tout = out.concat(stream.readBytes(size));\n\t\t}\n\t\treturn out;\n\t}\n};\n\n// global control extension\nvar gce = {\n\tlabel: 'gce',\n\trequires: function(stream){\n\t\t// just peek at the top two bytes, and if true do this\n\t\tvar codes = stream.peekBytes(2);\n\t\treturn codes[0] === 0x21 && codes[1] === 0xF9;\n\t},\n\tparts: [\n\t\t{ label: 'codes', parser: Parsers.readBytes(2), skip: true },\n\t\t{ label: 'byteSize', parser: Parsers.readByte() },\n\t\t{ label: 'extras', bits: {\n\t\t\tfuture: { index: 0, length: 3 },\n\t\t\tdisposal: { index: 3, length: 3 },\n\t\t\tuserInput: { index: 6 },\n\t\t\ttransparentColorGiven: { index: 7 }\n\t\t}},\n\t\t{ label: 'delay', parser: Parsers.readUnsigned(true) },\n\t\t{ label: 'transparentColorIndex', parser: Parsers.readByte() },\n\t\t{ label: 'terminator', parser: Parsers.readByte(), skip: true }\n\t]\n};\n\n// image pipeline block\nvar image = {\n\tlabel: 'image',\n\trequires: function(stream){\n\t\t// peek at the next byte\n\t\tvar code = stream.peekByte();\n\t\treturn code === 0x2C;\n\t},\n\tparts: [\n\t\t{ label: 'code', parser: Parsers.readByte(), skip: true },\n\t\t{\n\t\t\tlabel: 'descriptor', // image descriptor\n\t\t\tparts: [\n\t\t\t\t{ label: 'left', parser: Parsers.readUnsigned(true) },\n\t\t\t\t{ label: 'top', parser: Parsers.readUnsigned(true) },\n\t\t\t\t{ label: 'width', parser: Parsers.readUnsigned(true) },\n\t\t\t\t{ label: 'height', parser: Parsers.readUnsigned(true) },\n\t\t\t\t{ label: 'lct', bits: {\n\t\t\t\t\texists: { index: 0 },\n\t\t\t\t\tinterlaced: { index: 1 },\n\t\t\t\t\tsort: { index: 2 },\n\t\t\t\t\tfuture: { index: 3, length: 2 },\n\t\t\t\t\tsize: { index: 5, length: 3 }\n\t\t\t\t}}\n\t\t\t]\n\t\t},{\n\t\t\tlabel: 'lct', // optional local color table\n\t\t\trequires: function(stream, obj, parent){\n\t\t\t\treturn parent.descriptor.lct.exists;\n\t\t\t},\n\t\t\tparser: Parsers.readArray(3, function(stream, obj, parent){\n\t\t\t\treturn Math.pow(2, parent.descriptor.lct.size + 1);\n\t\t\t})\n\t\t},{\n\t\t\tlabel: 'data', // the image data blocks\n\t\t\tparts: [\n\t\t\t\t{ label: 'minCodeSize', parser: Parsers.readByte() },\n\t\t\t\tsubBlocks\n\t\t\t]\n\t\t}\n\t]\n};\n\n// plain text block\nvar text = {\n\tlabel: 'text',\n\trequires: function(stream){\n\t\t// just peek at the top two bytes, and if true do this\n\t\tvar codes = stream.peekBytes(2);\n\t\treturn codes[0] === 0x21 && codes[1] === 0x01;\n\t},\n\tparts: [\n\t\t{ label: 'codes', parser: Parsers.readBytes(2), skip: true },\n\t\t{ label: 'blockSize', parser: Parsers.readByte() },\n\t\t{\n\t\t\tlabel: 'preData',\n\t\t\tparser: function(stream, obj, parent){\n\t\t\t\treturn stream.readBytes(parent.text.blockSize);\n\t\t\t}\n\t\t},\n\t\tsubBlocks\n\t]\n};\n\n// application block\nvar application = {\n\tlabel: 'application',\n\trequires: function(stream, obj, parent){\n\t\t// make sure this frame doesn't already have a gce, text, comment, or image\n\t\t// as that means this block should be attached to the next frame\n\t\t//if(parent.gce || parent.text || parent.image || parent.comment){ return false; }\n\n\t\t// peek at the top two bytes\n\t\tvar codes = stream.peekBytes(2);\n\t\treturn codes[0] === 0x21 && codes[1] === 0xFF;\n\t},\n\tparts: [\n\t\t{ label: 'codes', parser: Parsers.readBytes(2), skip: true },\n\t\t{ label: 'blockSize', parser: Parsers.readByte() },\n\t\t{\n\t\t\tlabel: 'id',\n\t\t\tparser: function(stream, obj, parent){\n\t\t\t\treturn stream.readString(parent.blockSize);\n\t\t\t}\n\t\t},\n\t\tsubBlocks\n\t]\n};\n\n// comment block\nvar comment = {\n\tlabel: 'comment',\n\trequires: function(stream, obj, parent){\n\t\t// make sure this frame doesn't already have a gce, text, comment, or image\n\t\t// as that means this block should be attached to the next frame\n\t\t//if(parent.gce || parent.text || parent.image || parent.comment){ return false; }\n\n\t\t// peek at the top two bytes\n\t\tvar codes = stream.peekBytes(2);\n\t\treturn codes[0] === 0x21 && codes[1] === 0xFE;\n\t},\n\tparts: [\n\t\t{ label: 'codes', parser: Parsers.readBytes(2), skip: true },\n\t\tsubBlocks\n\t]\n};\n\n// frames of ext and image data\nvar frames = {\n\tlabel: 'frames',\n\tparts: [\n\t\tgce,\n\t\tapplication,\n\t\tcomment,\n\t\timage,\n\t\ttext\n\t],\n\tloop: function(stream){\n\t\tvar nextCode = stream.peekByte();\n\t\t// rather than check for a terminator, we should check for the existence\n\t\t// of an ext or image block to avoid infinite loops\n\t\t//var terminator = 0x3B;\n\t\t//return nextCode !== terminator;\n\t\treturn nextCode === 0x21 || nextCode === 0x2C;\n\t}\n};\n\n// main GIF schema\nvar schemaGIF = [\n\t{\n\t\tlabel: 'header', // gif header\n\t\tparts: [\n\t\t\t{ label: 'signature', parser: Parsers.readString(3) },\n\t\t\t{ label: 'version', parser: Parsers.readString(3) }\n\t\t]\n\t},{\n\t\tlabel: 'lsd', // local screen descriptor\n\t\tparts: [\n\t\t\t{ label: 'width', parser: Parsers.readUnsigned(true) },\n\t\t\t{ label: 'height', parser: Parsers.readUnsigned(true) },\n\t\t\t{ label: 'gct', bits: {\n\t\t\t\texists: { index: 0 },\n\t\t\t\tresolution: { index: 1, length: 3 },\n\t\t\t\tsort: { index: 4 },\n\t\t\t\tsize: { index: 5, length: 3 }\n\t\t\t}},\n\t\t\t{ label: 'backgroundColorIndex', parser: Parsers.readByte() },\n\t\t\t{ label: 'pixelAspectRatio', parser: Parsers.readByte() }\n\t\t]\n\t},{\n\t\tlabel: 'gct', // global color table\n\t\trequires: function(stream, obj){\n\t\t\treturn obj.lsd.gct.exists;\n\t\t},\n\t\tparser: Parsers.readArray(3, function(stream, obj){\n\t\t\treturn Math.pow(2, obj.lsd.gct.size + 1);\n\t\t})\n\t},\n\tframes // content frames\n];\n\nmodule.exports = schemaGIF;\n},{\"../bower_components/js-binary-schema-parser/src/parsers\":3}]},{},[4])\n\n\n//# sourceURL=webpack://Raycaster/./src/external/gifuct-js.min.js?");

/***/ }),

/***/ "./src/texture.worker.js":
/*!*******************************!*\
  !*** ./src/texture.worker.js ***!
  \*******************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _external_gifuct_js_min_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./external/gifuct-js.min.js */ \"./src/external/gifuct-js.min.js\");\n// Somehow works\r\n\r\n\r\nconst GIF = _external_gifuct_js_min_js__WEBPACK_IMPORTED_MODULE_0__[\"window\"].GIF;\r\n\r\nasync function GIFFrame(frame, options) {\r\n  let imageData = new ImageData(frame.patch, frame.dims.width, frame.dims.height);\r\n  let imageBitmap = await createImageBitmap(imageData, 0, 0, frame.dims.width, frame.dims.height);\r\n  return {\r\n    bmp: imageBitmap,\r\n    frameLength: frame.delay\r\n  };\r\n}\r\n\r\nself.addEventListener('message', function(e) {\r\n  let msg = e.data;\r\n  if (msg.type === 'loadGIF') {\r\n    let url = msg.url;\r\n    let options = msg.options;\r\n    fetch(url, {\r\n      method: 'GET'\r\n    })\r\n    .then((resp) => {\r\n      if (!resp.ok) {\r\n        throw new Error('Fetch failed at \"' + url + '\" ' + resp.statusText + \" (\" + resp.status + \")\");\r\n      }\r\n      else {\r\n        return resp.arrayBuffer();\r\n      }\r\n    })\r\n    .then((data) => new GIF(data))\r\n    .then((gif) => {\r\n      let frames = gif.decompressFrames(true);\r\n      if ('alpha' in options && !options.alpha) {\r\n        frames.forEach((f) => {\r\n          if (f.disposalType === 1) {\r\n            for (let i = 0; i < f.patch.length; i++) {\r\n              if (f.patch[i] === 0) {\r\n                f.patch[i] = 0;\r\n              }\r\n            }\r\n          }\r\n        });\r\n      }\r\n      frames.forEach((frame) => {\r\n        // delete frame.pixels;\r\n      });\r\n      let promisedFrames = frames.map((f) => GIFFrame(f, options));\r\n      Promise.all(promisedFrames).then((loadedFrames) => {\r\n        // console.log('finished',data);\r\n        self.postMessage({\r\n          type: 'loadGIF',\r\n          loadedFrames: loadedFrames\r\n        });\r\n      });\r\n    });\r\n  }\r\n  if (msg.type === 'loadGIFFrames') {\r\n\r\n  }\r\n});\r\n\n\n//# sourceURL=webpack://Raycaster/./src/texture.worker.js?");

/***/ })

/******/ });